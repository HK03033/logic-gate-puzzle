<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>論理ゲートパズル - 無限ステージ版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* カスタムフォント (Inter) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            user-select: none;
        }
        #circuitCanvas { background-color: #334155; } /* bg-slate-700 */
        .gate-toolbox { background-color: #475569; } /* bg-slate-600 */
        .gate-body { cursor: grab; } /* ゲート本体のカーソル */
        .gate.dragging .gate-body { cursor: grabbing; }
        .gate.dragging { opacity: 0.7; }
        .pin { cursor: crosshair; }
        .wire { cursor: pointer; stroke-width: 5px; } /* クリックしやすく太くする */
        .wire.on { stroke: #4ade80; } /* green-400 */
        .wire.off { stroke: #9ca3af; } /* gray-400 */
        .led.on { fill: #facc15; } /* yellow-400 */
        .led.off { fill: #6b7280; } /* gray-500 */
        #wiring-preview { stroke: #38bdf8; stroke-dasharray: 5,5; pointer-events: none; stroke-width: 3px; }

        /* メッセージモーダルのスタイル */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; }
        .modal-content { background-color: #1f2937; color: #f1f5f9; margin: auto; padding: 20px; border: 1px solid #334155; width: 80%; max-width: 400px; border-radius: 8px; text-align: center; }
        .modal-content.large { max-width: 600px; } /* 解説用にもう少し広く */
        .modal-button { background-color: #0ea5e9; color: white; padding: 10px 20px; margin-top: 15px; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.15s; }
        .modal-button:hover { background-color: #0284c7; }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 flex flex-col items-center justify-center min-h-screen p-2 md:p-4">

    <div class="w-full max-w-6xl bg-slate-800 shadow-2xl rounded-xl p-4 md:p-6">
        <header class="mb-4 text-center md:flex md:justify-between md:items-center">
            <div>
                <h1 class="text-2xl md:text-3xl font-bold text-sky-400">論理ゲートパズル</h1>
                <p id="stage-title" class="text-lg md:text-xl mt-1 text-slate-300">ステージ 1</p>
            </div>
            <div class="mt-2 md:mt-0 text-xl md:text-2xl font-semibold text-amber-400">
                スコア: <span id="score">0</span>
                <span class="ml-4">時間: <span id="timer">00:00</span></span>
            </div>
            <button id="difficultySelectButton" class="ml-4 bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition-colors duration-150">
                難易度選択
            </button>
        </header>

        <div class="flex flex-col md:flex-row gap-4">
            <div class="md:w-1/4 flex flex-col gap-4">
                <div class="bg-slate-700 p-4 rounded-lg shadow">
                    <h3 class="text-lg font-semibold mb-2 text-sky-300">課題</h3>
                    <div id="problem-description"></div>
                </div>
                <div id="gate-toolbox" class="gate-toolbox p-4 rounded-lg shadow flex-grow">
                    <h3 class="text-lg font-semibold mb-3 text-sky-300">ゲートツールボックス</h3>
                    <div id="gate-toolbox-items" class="grid grid-cols-2 gap-2">
                        </div>
                </div>
            </div>

            <div class="md:w-3/4">
                <div class="bg-slate-700 p-1 rounded-lg shadow aspect-video">
                    <svg id="circuitCanvas" width="100%" height="100%"></svg>
                </div>
            </div>
        </div>

        <footer class="text-center mt-4 flex justify-center items-center gap-4">
            <button id="resetButton" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition-colors duration-150 text-lg">
                リセット
            </button>
            <button id="checkButton" class="bg-sky-500 hover:bg-sky-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition-colors duration-150 text-lg">
                回路チェック！
            </button>
        </footer>
    </div>

    <div id="messageModal" class="modal">
        <div class="modal-content">
            <p id="modalMessageText"></p>
            <button id="modalCloseButton" class="modal-button">OK</button>
        </div>
    </div>

    <div id="explanationModal" class="modal">
        <div class="modal-content large">
            <h3 class="text-xl font-bold mb-3 text-sky-300">正解！ 次のステージへ！</h3>
            <div id="explanationContent" class="text-left text-slate-200 text-sm">
                </div>
            <button id="explanationCloseButton" class="modal-button">OK、次の問題へ</button>
        </div>
    </div>

    <div id="difficultyModal" class="modal" style="display: flex;">
      <div class="modal-content large">
        <h3 class="text-xl font-bold mb-3 text-sky-300">難易度を選択してください</h3>
        <div class="flex flex-col gap-3">
          <button class="modal-button" data-diff="tutorial">チュートリアル</button>
          <button class="modal-button" data-diff="easy">初級</button>
          <button class="modal-button" data-diff="normal">中級</button>
          <button class="modal-button" data-diff="hard">上級</button>
        </div>
      </div>
    </div>

    <div id="gateInfoModal" class="modal">
      <div class="modal-content large">
        <h3 id="gateInfoTitle" class="text-xl font-bold mb-3 text-sky-300"></h3>
        <div id="gateInfoBody" class="text-left text-slate-200 text-base"></div>
        <button id="gateInfoNextButton" class="modal-button mt-4">次へ</button>
      </div>
    </div>

    <script>
    // --- グローバル変数と定数 ---
    const SVG_NS = "http://www.w3.org/2000/svg";
    let score = 0;
    let stageLevel = 1;

    let currentStageData = {}; // 現在のステージの問題データを保持
    let userCircuit = { gates: [], wires: [] }; // ユーザーが作成した回路
    let savedRandomStageData = null; // ランダム問題の保存用

    // ドラッグ＆ドロップ関連の変数
    let isDragging = false;
    let draggedElement = null;
    let offset = { x: 0, y: 0 };
    let svgPoint; // SVG座標変換用

    // 配線関連の変数
    let isWiring = false;
    let wiringStartPin = null;
    let wiringPreviewLine = null;
    
    // タイマー関連の変数
    let timerInterval;
    let startTime;
    let timerEl; // タイマー表示要素

    // DOM要素
    let scoreEl, stageTitleEl, problemDescEl, gateToolboxEl, circuitCanvasEl;
    let checkButtonEl, resetButtonEl, modal, modalMessageText, modalCloseButton;
    let explanationModal, explanationContent, explanationCloseButton;

    let difficulty = "tutorial"; // デフォルトはチュートリアル
    let tutorialStageCount = 5;  // チュートリアルは5問

    // --- 初期化処理 ---
    document.addEventListener('DOMContentLoaded', () => {
        // DOM要素の取得
        scoreEl = document.getElementById('score');
        stageTitleEl = document.getElementById('stage-title');
        problemDescEl = document.getElementById('problem-description');
        gateToolboxEl = document.getElementById('gate-toolbox-items');
        circuitCanvasEl = document.getElementById('circuitCanvas');
        checkButtonEl = document.getElementById('checkButton');
        resetButtonEl = document.getElementById('resetButton');
        modal = document.getElementById('messageModal');
        modalMessageText = document.getElementById('modalMessageText');
        modalCloseButton = document.getElementById('modalCloseButton');
        timerEl = document.getElementById('timer'); // タイマー要素を取得

        explanationModal = document.getElementById('explanationModal');
        explanationContent = document.getElementById('explanationContent');
        explanationCloseButton = document.getElementById('explanationCloseButton');

        svgPoint = circuitCanvasEl.createSVGPoint();

        // ゲート説明モーダルのセットアップ
        setupGateInfoModal();

        // 難易度選択ボタンのイベント
        const difficultySelectButton = document.getElementById('difficultySelectButton');
        const difficultyModal = document.getElementById('difficultyModal');
        difficultySelectButton.addEventListener('click', () => {
            difficultyModal.style.display = 'flex';
        });

        // イベントリスナーの設定
        checkButtonEl.addEventListener('click', checkSolution);
        resetButtonEl.addEventListener('click', () => loadStage(stageLevel));
        modalCloseButton.addEventListener('click', closeModal);
        explanationCloseButton.addEventListener('click', closeExplanationModal);
        document.addEventListener('mousedown', onMouseDown);

        // 難易度選択モーダル
        difficultyModal.querySelectorAll('.modal-button').forEach(btn => {
            btn.addEventListener('click', (e) => {
                difficulty = btn.getAttribute('data-diff');
                stageLevel = 1;
                score = 0;
                savedRandomStageData = null;
                difficultyModal.style.display = 'none';
                if (difficulty === "tutorial") {
                    // ここで1問目の説明だけを表示
                    showGateInfoModal(0);
                    gateInfoNextButton.onclick = () => {
                        closeGateInfoModal();
                        actuallyLoadStage(1);
                    };
                } else {
                    loadStage(stageLevel);
                }
            });
        });
    });
    
    // --- タイマー関連関数 ---
    function startTimer() {
        clearInterval(timerInterval); // 既存のタイマーをクリア
        startTime = Date.now();
        timerInterval = setInterval(updateTimerDisplay, 1000);
    }

    function stopTimer() {
        clearInterval(timerInterval);
    }

    function updateTimerDisplay() {
        const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsedTime / 60);
        const seconds = elapsedTime % 60;
        timerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function getElapsedTimeInSeconds() {
        return Math.floor((Date.now() - startTime) / 1000);
    }

    // --- ステージ管理 ---
    function loadStage(level) {
        userCircuit = { gates: [], wires: [] };
        circuitCanvasEl.innerHTML = '';
        if (isWiring) cancelWiring();
        stopTimer(); // ステージロード時にタイマーを停止・リセット

        // チュートリアル時は各問題の前に説明モーダルを表示
        if (difficulty === "tutorial") {
            // ステージごとに説明を出す（1:NOT, 2:AND, 3:OR, 4:XOR, 5:NAND）
            if (level >= 1 && level <= 4) {
                showGateInfoModal(level - 1);
                gateInfoNextButton.onclick = () => {
                    closeGateInfoModal();
                    actuallyLoadStage(level);
                };
                return;
            }
        }
        actuallyLoadStage(level);
    }

    // 本来のloadStage処理を分離
    function actuallyLoadStage(level) {
        if (difficulty === "tutorial") {
            currentStageData = getTutorialStage(level);
            savedRandomStageData = null;
        } else if (difficulty === "easy") {
            // 初級は固定問題
            if (level <= 2) {
                currentStageData = getFixedStage(level);
                savedRandomStageData = null;
            } else {
                if (!savedRandomStageData) {
                    savedRandomStageData = generateRandomStage(level, "easy");
                }
                currentStageData = savedRandomStageData;
            }
        } else if (difficulty === "normal") {
            // 中級は2～4ゲートの自動生成
            if (!savedRandomStageData) {
                savedRandomStageData = generateRandomStage(level, "normal");
            }
            currentStageData = savedRandomStageData;
        } else if (difficulty === "hard") {
            // 上級は3～4ゲートの自動生成
            if (!savedRandomStageData) {
                savedRandomStageData = generateRandomStage(level, "hard");
            }
            currentStageData = savedRandomStageData;
        } else {
            // 念のため
            currentStageData = {};
        }

        stageTitleEl.textContent = `ステージ ${level}`;
        scoreEl.textContent = score;
        drawProblemDescription();
        drawToolbox();
        drawCanvasNodes();
        startTimer(); // ステージが描画されたらタイマーを開始
    }
    
    // --- 問題生成 ---
    function getFixedStage(level) {
        if (level === 1) {
            return {
                availableGates: [{ type: 'NOT', id: 'fixed_not1' }],
                inputs: [{ id: 'A' }], outputs: [{ id: 'X' }],
                expectedResults: [{ inputs: { A: false }, outputs: { X: true } }, { inputs: { A: true }, outputs: { X: false } }]
            };
        }
        if (level === 2) {
            return {
                availableGates: [{ type: 'AND', id: 'fixed_and1' }],
                inputs: [{ id: 'A' }, { id: 'B' }], outputs: [{ id: 'Y' }],
                expectedResults: [
                    { inputs: { A: false, B: false }, outputs: { Y: false } }, { inputs: { A: true, B: false }, outputs: { Y: false } },
                    { inputs: { A: false, B: true }, outputs: { Y: false } }, { inputs: { A: true, B: true }, outputs: { Y: true } }
                ]
            };
        }
        return {}; // 念のため
    }
    
    function generateRandomStage(level, diff) {
        const gateTypes = ['AND', 'OR', 'NOT', 'XOR'];
        let numGates;
        if (diff === "normal") {
            numGates = Math.max(2, Math.min(Math.floor(level / 2) + 1, 4));
        } else if (diff === "hard") {
            numGates = Math.max(3, Math.min(Math.floor(level / 2) + 2, 4));
        } else {
            // easyやその他は従来通り
            numGates = Math.min(Math.floor(level / 2) + 1, 4);
        }
        let availableGates = [], internalWires = [], gatePool = {};

        for (let i = 0; i < numGates; i++) {
            const type = gateTypes[Math.floor(Math.random() * gateTypes.length)];
            const id = `rand_gate${i}`;
            availableGates.push({ type, id });
            gatePool[id] = { type, inputs: [] };
        }

        const inputs = [{id: 'A'}, {id: 'B'}];
        let availableOutputs = ['A', 'B'];
        let unconnectedGates = [...availableGates];

        // ゲート間の接続をランダムに決定
        while(unconnectedGates.length > 0) {
            const gate = unconnectedGates.shift();
            const numInputs = gate.type === 'NOT' ? 1 : 2;
            for(let i = 0; i < numInputs; i++) {
                const sourceIndex = Math.floor(Math.random() * availableOutputs.length);
                const source = availableOutputs.length > 0 ? availableOutputs.splice(sourceIndex, 1)[0] : (Math.random() > 0.5 ? 'A' : 'B');
                internalWires.push({ from: source, to: `${gate.id}.input${i}`});
                gatePool[gate.id].inputs.push(source);
            }
            availableOutputs.push(`${gate.id}.output`);
        }
        
        // 最終的な出力を設定
        const finalOutputId = availableOutputs[availableOutputs.length - 1];
        const outputs = [{id: 'Z'}];
        internalWires.push({ from: finalOutputId, to: 'Z'});

        // 期待される結果をシミュレート
        const expectedResults = [];
        [[false, false], [false, true], [true, false], [true, true]].forEach(pattern => {
            const signal = { A: pattern[0], B: pattern[1] };
            
            let currentSignals = { ...signal };
            let updatedThisLoop = true;
            let safetyCounter = 0;
            const MAX_ITERATIONS = 20;

            while (updatedThisLoop && safetyCounter < MAX_ITERATIONS) {
                updatedThisLoop = false;
                internalWires.forEach(wire => {
                    if (currentSignals[wire.from] !== undefined && currentSignals[wire.to] === undefined) {
                        const targetGateId = wire.to.split('.')[0];
                        const inputPinIndex = wire.to.includes('input0') ? 0 : 1;

                        const gate = availableGates.find(g => g.id === targetGateId);
                        if (gate) {
                            const gateInputPins = gatePool[gate.id].inputs;
                            const allInputsReady = gateInputPins.every(inputPinId => currentSignals[inputPinId] !== undefined);

                            if (allInputsReady) {
                                const gateInputs = gateInputPins.map(inputPinId => currentSignals[inputPinId]);
                                currentSignals[`${gate.id}.output`] = calculateGateOutput(gate.type, gateInputs);
                                updatedThisLoop = true;
                            }
                        } else if (wire.to === 'Z') {
                            currentSignals['Z'] = currentSignals[wire.from];
                            updatedThisLoop = true;
                        }
                    }
                });
                safetyCounter++;
            }

            expectedResults.push({ inputs: { A: pattern[0], B: pattern[1] }, outputs: { Z: currentSignals['Z'] } });
        });

        // ゲートのIDを「gate1」「gate2」のように連番にリマップ
        const remappedAvailableGates = availableGates.map((gate, index) => ({
            type: gate.type,
            id: `gate${index + 1}`
        }));

        // 期待される結果を計算するための「正解回路」情報を追加
        const solutionCircuit = {
            gates: remappedAvailableGates.map((gate, index) => ({
                id: gate.id,
                type: gate.type,
            })),
            wires: internalWires.map(wire => {
                let from = wire.from;
                let to = wire.to;

                remappedAvailableGates.forEach((g, index) => {
                    const originalId = availableGates[index].id;
                    if (from.startsWith(originalId)) {
                        from = from.replace(originalId, g.id);
                    }
                    if (to.startsWith(originalId)) {
                        to = to.replace(originalId, g.id);
                    }
                });
                return { from, to };
            })
        };

        return { availableGates: remappedAvailableGates, inputs, outputs, expectedResults, solutionCircuit };
    }


    // --- 描画関数 ---
    function drawProblemDescription() {
        let html = '<p class="text-slate-300 mb-2">下のゲートをすべて使って、指定の出力を再現しよう。</p>';
        html += '<table class="w-full text-center">';
        const headers = [...currentStageData.inputs.map(i => i.id), ...currentStageData.outputs.map(o => o.id)];
        html += `<thead><tr>${headers.map(h => `<th class="p-1 border border-slate-500">${h}</th>`).join('')}</tr></thead>`;
        html += '<tbody>';
        currentStageData.expectedResults.forEach(res => {
            html += '<tr>';
            currentStageData.inputs.forEach(input => { html += `<td class="p-1 border border-slate-500">${res.inputs[input.id] ? 'ON' : 'OFF'}</td>`; });
            currentStageData.outputs.forEach(output => { html += `<td class="p-1 border border-slate-500 font-bold text-amber-300">${res.outputs[output.id] ? 'ON' : 'OFF'}</td>`; });
            html += '</tr>';
        });
        html += '</tbody></table>';
        problemDescEl.innerHTML = html;
    }
    function drawToolbox() {
        gateToolboxEl.innerHTML = '';
        currentStageData.availableGates.forEach(gate => {
            const g = createGateElement(gate.type, gate.id, true);
            const wrapper = document.createElement('div');
            wrapper.appendChild(g);
            gateToolboxEl.appendChild(wrapper);
        });
    }
    function drawCanvasNodes() {
        const canvasRect = circuitCanvasEl.getBoundingClientRect();
        currentStageData.inputs.forEach((input, index) => {
             const y = (canvasRect.height / (currentStageData.inputs.length + 1)) * (index + 1);
             createNode(input.id, 'input', 50, y);
        });
        currentStageData.outputs.forEach((output, index) => {
             const y = (canvasRect.height / (currentStageData.outputs.length + 1)) * (index + 1);
             createNode(output.id, 'output', canvasRect.width - 50, y);
        });
    }
    function createGateElement(type, id, isToolbox) {
        const g = document.createElementNS(SVG_NS, 'g');
        g.setAttribute('class', 'gate');
        g.setAttribute('data-id', id);
        g.setAttribute('data-type', type);
        
        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.setAttribute('width', 80);
        rect.setAttribute('height', type === 'NOT' ? 40: 60);
        rect.setAttribute('rx', 5);
        rect.setAttribute('class', 'fill-slate-500 stroke-slate-400 gate-body');
        g.appendChild(rect);

        const text = document.createElementNS(SVG_NS, 'text');
        text.setAttribute('x', 40);
        text.setAttribute('y', type === 'NOT' ? 24: 34);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('class', 'fill-sky-300 font-semibold gate-body');
        text.textContent = type;
        g.appendChild(text);

        const numInputs = type === 'NOT' ? 1 : 2;
        for (let i = 0; i < numInputs; i++) {
            g.appendChild(createPinElement(`${id}.input${i}`, 0, ((type === 'NOT' ? 40: 60) / (numInputs + 1)) * (i + 1)));
        }
        g.appendChild(createPinElement(`${id}.output`, 80, (type === 'NOT' ? 40: 60) / 2));
        
        if (isToolbox) {
             const svg = document.createElementNS(SVG_NS, 'svg');
             svg.setAttribute('viewBox', '-10 -10 100 80');
             svg.appendChild(g);
             return svg;
        }
        return g;
    }
    function createPinElement(id, cx, cy) {
        const pin = document.createElementNS(SVG_NS, 'circle');
        pin.setAttribute('class', 'pin fill-slate-400 hover:fill-sky-400');
        pin.setAttribute('data-id', id);
        pin.setAttribute('cx', cx);
        pin.setAttribute('cy', cy);
        pin.setAttribute('r', 5);
        return pin;
    }
    function createNode(id, type, x, y) {
        const g = document.createElementNS(SVG_NS, 'g');
        g.setAttribute('transform', `translate(${x}, ${y})`);
        const circle = document.createElementNS(SVG_NS, 'circle');
        circle.setAttribute('r', 10);
        circle.setAttribute('class', `pin ${type === 'input' ? 'led off' : 'led off'}`);
        circle.setAttribute('data-id', id);
        g.appendChild(circle);
        const text = document.createElementNS(SVG_NS, 'text');
        text.setAttribute('x', type === 'input' ? 15 : -15);
        text.setAttribute('y', 5);
        text.setAttribute('text-anchor', type === 'input' ? 'start' : 'end');
        text.setAttribute('class', 'fill-slate-200 font-bold');
        text.textContent = id;
        g.appendChild(text);
        circuitCanvasEl.appendChild(g);
    }
    
    // --- マウスイベント処理 ---
    function getMousePosition(evt) {
        svgPoint.x = evt.clientX;
        svgPoint.y = evt.clientY;
        return svgPoint.matrixTransform(circuitCanvasEl.getScreenCTM().inverse());
    }

    function onMouseDown(e) {
        if (e.target.classList.contains('wire')) {
            const fromId = e.target.getAttribute('data-from');
            const toId = e.target.getAttribute('data-to');
            userCircuit.wires = userCircuit.wires.filter(w => !(w.from === fromId && w.to === toId));
            drawUserWires();
            return;
        }
        const targetPin = e.target.closest('.pin');
        if (targetPin) {
            e.preventDefault();
            handlePinClick(targetPin);
            return;
        }
        const targetGateBody = e.target.closest('.gate-body');
        if (targetGateBody) {
            e.preventDefault();
            handleGateMouseDown(e, targetGateBody.closest('.gate'));
            return;
        }
        
        if (isWiring) {
            cancelWiring();
        }
    }

    function handleGateMouseDown(e, gateElement) {
        if (isWiring) cancelWiring();
        isDragging = true;

        if (gateElement.closest('#gate-toolbox')) {
            const type = gateElement.getAttribute('data-type');
            const id = gateElement.getAttribute('data-id');
            gateElement.closest('svg').parentElement.remove();

            const canvasRect = circuitCanvasEl.getBoundingClientRect();
            const gateWidth = 80, gateHeight = (type === 'NOT' ? 40 : 60);
            const centerX = canvasRect.width / 2 - gateWidth / 2;
            const centerY = canvasRect.height / 2 - gateHeight / 2;

            const newGateEl = createGateElement(type, id, false);
            circuitCanvasEl.appendChild(newGateEl);
            draggedElement = newGateEl;

            userCircuit.gates.push({type, id, x: centerX, y: centerY});
            newGateEl.setAttribute('transform', `translate(${centerX}, ${centerY})`);
            offset = { x: (getMousePosition(e).x - centerX), y: (getMousePosition(e).y - centerY) };
        } else {
            draggedElement = gateElement;
            const pos = getMousePosition(e);
            const transform = draggedElement.transform.baseVal.getItem(0);
            offset.x = pos.x - transform.matrix.e;
            offset.y = pos.y - transform.matrix.f;
        }

        draggedElement.classList.add('dragging');
        document.addEventListener('mousemove', onMouseMoveForDragging);
        document.addEventListener('mouseup', onMouseUpForDragging);
    }

    function onMouseMoveForDragging(e) {
        if (!isDragging) return;
        e.preventDefault();
        const pos = getMousePosition(e);
        const canvasRect = circuitCanvasEl.getBoundingClientRect();
        const type = draggedElement.getAttribute('data-type');
        const gateWidth = 80, gateHeight = (type === 'NOT' ? 40 : 60);
        let newX = Math.max(0, Math.min(pos.x - offset.x, canvasRect.width - gateWidth));
        let newY = Math.max(0, Math.min(pos.y - offset.y, canvasRect.height - gateHeight));
        draggedElement.setAttribute('transform', `translate(${newX}, ${newY})`);
    }

    function onMouseUpForDragging(e) {
        if (!isDragging) return;
        
        draggedElement.classList.remove('dragging');
        const gateData = userCircuit.gates.find(g => g.id === draggedElement.dataset.id);
        if (gateData) {
            const transform = draggedElement.transform.baseVal.getItem(0).matrix;
            gateData.x = transform.e;
            gateData.y = transform.f;
        }
        
        isDragging = false;
        draggedElement = null;
        drawUserWires();

        document.removeEventListener('mousemove', onMouseMoveForDragging);
        document.removeEventListener('mouseup', onMouseUpForDragging);
    }

    function handlePinClick(pinElement) {
        if (!isWiring) {
            isWiring = true;
            wiringStartPin = pinElement;
            
            wiringPreviewLine = document.createElementNS(SVG_NS, 'line');
            wiringPreviewLine.setAttribute('id', 'wiring-preview');
            const startPos = getPinPosition(wiringStartPin);
            wiringPreviewLine.setAttribute('x1', startPos.x);
            wiringPreviewLine.setAttribute('y1', startPos.y);
            wiringPreviewLine.setAttribute('x2', startPos.x);
            wiringPreviewLine.setAttribute('y2', startPos.y);
            circuitCanvasEl.appendChild(wiringPreviewLine);

            document.addEventListener('mousemove', onMouseMoveForWiring);
        } else {
            const endPin = pinElement;
            const startType = getPinType(wiringStartPin.dataset.id);
            const endType = getPinType(endPin.dataset.id);
            
            if (startType !== 'unknown' && endType !== 'unknown' && startType !== endType) {
             const fromPinId = startType === 'output' ? wiringStartPin.dataset.id : endPin.dataset.id;
             const toPinId = startType === 'input' ? wiringStartPin.dataset.id : endPin.dataset.id;
            userCircuit.wires.push({ from: fromPinId, to: toPinId });
            drawUserWires();
        }
            
            cancelWiring();
        }
    }

    function onMouseMoveForWiring(e) {
        if (!isWiring) return;
        e.preventDefault();
        const pos = getMousePosition(e);
        wiringPreviewLine.setAttribute('x2', pos.x);
        wiringPreviewLine.setAttribute('y2', pos.y);
    }
    
    function cancelWiring() {
        isWiring = false;
        wiringStartPin = null;
        if (wiringPreviewLine) {
            circuitCanvasEl.removeChild(wiringPreviewLine);
            wiringPreviewLine = null;
        }
        document.removeEventListener('mousemove', onMouseMoveForWiring);
    }

    function drawUserWires() {
        circuitCanvasEl.querySelectorAll('.wire').forEach(w => w.remove());
        userCircuit.wires.forEach(wire => {
             const fromPin = circuitCanvasEl.querySelector(`[data-id="${wire.from}"]`);
             const toPin = circuitCanvasEl.querySelector(`[data-id="${wire.to}"]`);
             if(fromPin && toPin) {
                 const line = document.createElementNS(SVG_NS, 'line');
                 const p1 = getPinPosition(fromPin);
                 const p2 = getPinPosition(toPin);
                 line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y);
                 line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
                 line.setAttribute('class', 'wire off');
                 line.setAttribute('data-from', wire.from);
                 line.setAttribute('data-to', wire.to);
                 circuitCanvasEl.insertBefore(line, circuitCanvasEl.firstChild);
             }
        });
    }

    function getPinPosition(pin) {
        const parentG = pin.closest('g');
        const transform = parentG.transform.baseVal.getItem(0).matrix;
        const cx = parseFloat(pin.getAttribute('cx') || 0);
        const cy = parseFloat(pin.getAttribute('cy') || 0);
        return { x: cx + transform.e, y: cy + transform.f };
    }

    function getPinType(pinId) {
        if (pinId.includes('.output')) return 'output';
        if (pinId.includes('.input')) return 'input';
        if (currentStageData.inputs.some(i => i.id === pinId)) return 'output'; // 入力ノードは出力ピンとして機能
        if (currentStageData.outputs.some(o => o.id === pinId)) return 'input'; // 出力ノードは入力ピンとして機能
        return 'unknown';
    }
    
    // --- シミュレーションと解答チェック ---
    function calculateGateOutput(type, inputs) {
        switch (type) {
            case 'NOT': return !inputs[0];
            case 'AND': return inputs[0] && inputs[1];
            case 'OR':  return inputs[0] || inputs[1];
            case 'XOR': return inputs[0] !== inputs[1];
            default: return false;
        }
    }

    function simulateCircuit(circuit, inputValues) {
        const signals = { ...inputValues };
        let changed = true;
        let iterations = 0;
        const MAX_ITERATIONS = 20;

        while(changed && iterations < MAX_ITERATIONS) {
            changed = false;
            circuit.gates.forEach(gate => {
                const outputId = `${gate.id}.output`;
                if(signals[outputId] === undefined) {
                    const inputWires = circuit.wires.filter(w => w.to.startsWith(gate.id));
                    const gateInputs = [];
                    let allInputsReady = true;
                    if (gate.type === 'NOT') {
                        const inputPinId = `${gate.id}.input0`;
                        const connectedWire = inputWires.find(w => w.to === inputPinId);
                        if (connectedWire && signals[connectedWire.from] !== undefined) {
                            gateInputs.push(signals[connectedWire.from]);
                        } else {
                            allInputsReady = false;
                        }
                    } else { // AND, OR, XOR
                        const input0PinId = `${gate.id}.input0`;
                        const input1PinId = `${gate.id}.input1`;
                        const connectedWire0 = inputWires.find(w => w.to === input0PinId);
                        const connectedWire1 = inputWires.find(w => w.to === input1PinId);
                        
                        if (connectedWire0 && signals[connectedWire0.from] !== undefined &&
                            connectedWire1 && signals[connectedWire1.from] !== undefined) {
                            gateInputs.push(signals[connectedWire0.from]);
                            gateInputs.push(signals[connectedWire1.from]);
                        } else {
                            allInputsReady = false;
                        }
                    }

                    if(allInputsReady && gateInputs.length > 0) {
                        signals[outputId] = calculateGateOutput(gate.type, gateInputs);
                        changed = true;
                    }
                }
            });

            currentStageData.outputs.forEach(outputNode => {
                if (signals[outputNode.id] === undefined) {
                    const finalWire = circuit.wires.find(w => w.to === outputNode.id);
                    if (finalWire && signals[finalWire.from] !== undefined) {
                        signals[outputNode.id] = signals[finalWire.from];
                        changed = true;
                    }
                }
            });
            iterations++;
        }
        return signals;
    }


    function checkSolution() {
        const usedGateCount = userCircuit.gates.length;
        const availableGateCount = currentStageData.availableGates.length;
        if (usedGateCount !== availableGateCount) {
            showModal(`ツールボックスのゲートを全て使ってください。現在 ${usedGateCount} / ${availableGateCount} 個使用しています。`);
            return;
        }

        let allPatternsPass = true;
        for (const testCase of currentStageData.expectedResults) {
            const resultSignals = simulateCircuit(userCircuit, testCase.inputs);
            for (const output of currentStageData.outputs) {
                const actualOutput = resultSignals[output.id];
                if (actualOutput !== testCase.outputs[output.id]) {
                    allPatternsPass = false; break;
                }
            }
            if (!allPatternsPass) break;
        }

        if (allPatternsPass) {
            stopTimer(); // 正解したらタイマーを停止
            const elapsedTime = getElapsedTimeInSeconds();
            const timeBonus = Math.max(1, 100 - Math.floor(elapsedTime / 2)); // 経過時間に応じてボーナスを減点、最低1点
            const stageScore = (10 * stageLevel) + timeBonus;
            score += stageScore;

            const clearedStageLevel = stageLevel;
            stageLevel++;

            savedRandomStageData = null;
            showExplanationModal(clearedStageLevel, stageScore, elapsedTime, timeBonus); // 時間情報を渡す

            // チュートリアル終了時
            if (difficulty === "tutorial" && stageLevel > tutorialStageCount) {
                setTimeout(() => {
                    // まず難易度選択モーダルを隠す
                    difficultyModal.style.display = 'none';
                    // 先に「お疲れさまでした」モーダルを表示
                    showModal("チュートリアルクリア！お疲れさまでした。他の難易度にも挑戦してみましょう！");
                    // OKボタン押下時に難易度選択モーダルを再表示
                    modalCloseButton.onclick = () => {
                        closeModal();
                        difficultyModal.style.display = 'flex';
                    };
                }, 500);
            }
        } else {
            showModal('不正解です。回路の接続を見直してください。');
        }
    }
    
    // --- モーダル表示関数 ---
    function closeModal() { modal.style.display = 'none'; }
    function showModal(message) { modalMessageText.textContent = message; modal.style.display = 'flex'; }

    function showExplanationModal(clearedStageLevel, stageScore, elapsedTime, timeBonus) {
        let explanationHtml = `<p class="mb-3">ステージ${clearedStageLevel}をクリアしました！ お見事です！</p>`;
        explanationHtml += `<p class="mb-3">獲得スコア: ${stageScore} (時間ボーナス: ${timeBonus})</p>`;
        explanationHtml += `<p class="mb-3">クリアタイム: ${String(Math.floor(elapsedTime / 60)).padStart(2, '0')}:${String(elapsedTime % 60).padStart(2, '0')}</p>`;
        
        if (clearedStageLevel === 1) {
            explanationHtml += `
                <p>このステージでは **NOTゲート** を使いましたね。</p>
                <p>NOTゲートは、入力と出力が逆になります。</p>
                <p>ON (真) が入力されれば OFF (偽) に、OFF (偽) が入力されれば ON (真) になります。</p>
                <table class="w-full text-center mt-3 border border-slate-600">
                    <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力 A</th><th class="p-1 border border-slate-600">出力 X</th></tr></thead>
                    <tbody>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr>
                    </tbody>
                </table>
            `;
        } else if (clearedStageLevel === 2) {
            explanationHtml += `
                <p>このステージでは **ANDゲート** を使いました。</p>
                <p>ANDゲートは、全ての入力がONの時に限り出力がONになります。</p>
                <table class="w-full text-center mt-3 border border-slate-600">
                    <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力 A</th><th class="p-1 border border-slate-600">入力 B</th><th class="p-1 border border-slate-600">出力 Y</th></tr></thead>
                    <tbody>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                    </tbody>
                </table>
            `;
        } else if (clearedStageLevel === 3) {
            explanationHtml += `
                <p>このステージでは **ORゲート** を使いました。</p>
                <p>ORゲートは、いずれかの入力がONの時に出力がONになります。</p>
                <table class="w-full text-center mt-3 border border-slate-600">
                    <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力 A</th><th class="p-1 border border-slate-600">入力 B</th><th class="p-1 border border-slate-600">出力 Z</th></tr></thead>
                    <tbody>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                    </tbody>
                </table>
            `;
        } else if (clearedStageLevel === 4) {
            explanationHtml += `
                <p>このステージでは **XORゲート** を使いました。</p>
                <p>XORゲートは、入力のいずれか一方がONの時に出力がONになります。</p>
                <table class="w-full text-center mt-3 border border-slate-600">
                    <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力 A</th><th class="p-1 border border-slate-600">入力 B</th><th class="p-1 border border-slate-600">出力 Z</th></tr></thead>
                    <tbody>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr>
                    </tbody>
                </table>
            `;
        } else {
            explanationHtml += `
                <p>今回の問題は、**論理ゲートの組み合わせ** でした。</p>
                <p>正解となる回路の各ステップでの信号変化を見てみましょう。</p>
                <table class="w-full text-center mt-3 border border-slate-600">
                    <thead>
                        <tr class="bg-slate-700">
                            ${currentStageData.inputs.map(i => `<th class="p-1 border border-slate-600">${i.id}</th>`).join('')}
                            ${currentStageData.solutionCircuit.gates.map(g => `<th class="p-1 border border-slate-600">${g.type}<br/>(${g.id}.output)</th>`).join('')}
                            ${currentStageData.outputs.map(o => `<th class="p-1 border border-slate-600">${o.id}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
            `;

            currentStageData.expectedResults.forEach(res => {
                const fullSignals = simulateCircuit(currentStageData.solutionCircuit, res.inputs);
                explanationHtml += '<tr>';
                currentStageData.inputs.forEach(input => {
                    explanationHtml += `<td class="p-1 border border-slate-600">${fullSignals[input.id] ? 'ON' : 'OFF'}</td>`;
                });
                currentStageData.solutionCircuit.gates.forEach(gate => {
                    const outputId = `${gate.id}.output`;
                    explanationHtml += `<td class="p-1 border border-slate-600">${fullSignals[outputId] ? 'ON' : 'OFF'}</td>`;
                });
                currentStageData.outputs.forEach(output => {
                    explanationHtml += `<td class="p-1 border border-slate-600 font-bold text-amber-300">${fullSignals[output.id] ? 'ON' : 'OFF'}</td>`;
                });
                explanationHtml += '</tr>';
            });

            explanationHtml += `
                    </tbody>
                </table>
                <p class="mt-3 text-sm text-slate-400">
                    ※上記の表は正解回路における各ゲートの出力状態を示しています。<br/>
                    この組み合わせで、与えられた入力を元に最終出力が生成されます。
                </p>
            `;
        }

        explanationContent.innerHTML = explanationHtml;
        explanationModal.style.display = 'flex';
    }

    function closeExplanationModal() {
        explanationModal.style.display = 'none';
        loadStage(stageLevel); // 次のステージをロード
    }

    function getTutorialStage(level) {
        // 1,2問目は既存のgetFixedStageを流用
        if (level === 1) return getFixedStage(1);
        if (level === 2) return getFixedStage(2);
        // 3問目: ORゲート
        if (level === 3) {
            return {
                availableGates: [{ type: 'OR', id: 'fixed_or1' }],
                inputs: [{ id: 'A' }, { id: 'B' }], outputs: [{ id: 'Z' }],
                expectedResults: [
                    { inputs: { A: false, B: false }, outputs: { Z: false } },
                    { inputs: { A: true, B: false }, outputs: { Z: true } },
                    { inputs: { A: false, B: true }, outputs: { Z: true } },
                    { inputs: { A: true, B: true }, outputs: { Z: true } }
                ],
                solutionCircuit: {
                    gates: [{ id: 'fixed_or1', type: 'OR' }],
                    wires: [
                        { from: 'A', to: 'fixed_or1.input0' },
                        { from: 'B', to: 'fixed_or1.input1' },
                        { from: 'fixed_or1.output', to: 'Z' }
                    ]
                }
            };
        }
        // 4問目: XORゲート
        if (level === 4) {
            return {
                availableGates: [{ type: 'XOR', id: 'fixed_xor1' }],
                inputs: [{ id: 'A' }, { id: 'B' }], outputs: [{ id: 'Z' }],
                expectedResults: [
                    { inputs: { A: false, B: false }, outputs: { Z: false } },
                    { inputs: { A: true, B: false }, outputs: { Z: true } },
                    { inputs: { A: false, B: true }, outputs: { Z: true } },
                    { inputs: { A: true, B: true }, outputs: { Z: false } }
                ],
                solutionCircuit: {
                    gates: [{ id: 'fixed_xor1', type: 'XOR' }],
                    wires: [
                        { from: 'A', to: 'fixed_xor1.input0' },
                        { from: 'B', to: 'fixed_xor1.input1' },
                        { from: 'fixed_xor1.output', to: 'Z' }
                    ]
                }
            };
        }
        // 5問目: AND+NOT（NAND相当）
        if (level === 5) {
            return {
                availableGates: [
                    { type: 'AND', id: 'fixed_and2' },
                    { type: 'NOT', id: 'fixed_not2' }
                ],
                inputs: [{ id: 'A' }, { id: 'B' }], outputs: [{ id: 'Z' }],
                expectedResults: [
                    { inputs: { A: false, B: false }, outputs: { Z: true } },
                    { inputs: { A: true, B: false }, outputs: { Z: true } },
                    { inputs: { A: false, B: true }, outputs: { Z: true } },
                    { inputs: { A: true, B: true }, outputs: { Z: false } }
                ],
                solutionCircuit: {
                    gates: [
                        { id: 'fixed_and2', type: 'AND' },
                        { id: 'fixed_not2', type: 'NOT' }
                    ],
                    wires: [
                        { from: 'A', to: 'fixed_and2.input0' },
                        { from: 'B', to: 'fixed_and2.input1' },
                        { from: 'fixed_and2.output', to: 'fixed_not2.input0' },
                        { from: 'fixed_not2.output', to: 'Z' }
                    ]
                }
            };
        }
        // 6問目以降は終了
        return {
            availableGates: [],
            inputs: [],
            outputs: [],
            expectedResults: []
        };
    }

    // --- ゲート説明データ ---
const gateTutorials = [
    {
        title: "NOTゲート（否定）",
        body: `
            <p>NOTゲートは入力の値を反転します。</p>
            <ul class="list-disc ml-5 my-2">
                <li>入力がON（真）のとき、出力はOFF（偽）</li>
                <li>入力がOFF（偽）のとき、出力はON（真）</li>
            </ul>
            <table class="w-full text-center mt-2 border border-slate-600">
                <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力</th><th class="p-1 border border-slate-600">出力</th></tr></thead>
                <tbody>
                    <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr>
                    <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr>
                </tbody>
            </table>
        `
    },
    {
        title: "ANDゲート（論理積）",
        body: `
            <p>ANDゲートはすべての入力がON（真）のときだけ出力がONになります。</p>
            <table class="w-full text-center mt-2 border border-slate-600">
                <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力A</th><th class="p-1 border border-slate-600">入力B</th><th class="p-1 border border-slate-600">出力</th></tr></thead>
                <tbody>
                    <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                    <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                    <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr>
                    <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                </tbody>
            </table>
        `
    },
    {
        title: "ORゲート（論理和）",
        body: `
            <p>ORゲートはどちらか一方でも入力がON（真）なら出力がONになります。</p>
            <table class="w-full text-center mt-2 border border-slate-600">
                <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力A</th><th class="p-1 border border-slate-600">入力B</th><th class="p-1 border border-slate-600">出力</th></tr></thead>
                <tbody>
                    <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                    <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr>
                    <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                    <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                </tbody>
            </table>
        `
    },
    {
        title: "XORゲート（排他的論理和）",
        body: `
            <p>XORゲートは入力が異なるときだけ出力がON（真）になります。</p>
            <table class="w-full text-center mt-2 border border-slate-600">
                <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力A</th><th class="p-1 border border-slate-600">入力B</th><th class="p-1 border border-slate-600">出力</th></tr></thead>
                <tbody>
                    <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                    <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr>
                    <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                    <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr>
                </tbody>
            </table>
        `
    }
];

let gateInfoModal, gateInfoTitle, gateInfoBody, gateInfoNextButton;
let gateInfoIndex = 0;

function showGateInfoSequence() {
    gateInfoIndex = 0;
    showGateInfoModal(gateInfoIndex);
}

function showGateInfoModal(index) {
    gateInfoTitle.innerHTML = gateTutorials[index].title;
    gateInfoBody.innerHTML = gateTutorials[index].body;
    gateInfoModal.style.display = 'flex';
    gateInfoNextButton.textContent = (index === gateTutorials.length - 1) ? "チュートリアル開始" : "次へ";
}

function closeGateInfoModal() {
    gateInfoModal.style.display = 'none';
}

function setupGateInfoModal() {
    gateInfoModal = document.getElementById('gateInfoModal');
    gateInfoTitle = document.getElementById('gateInfoTitle');
    gateInfoBody = document.getElementById('gateInfoBody');
    gateInfoNextButton = document.getElementById('gateInfoNextButton');
    // ここでイベントリスナーは設定しない（loadStageや難易度選択時に都度設定する）
    }
    </script>
</body>
</html>