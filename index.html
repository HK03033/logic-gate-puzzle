<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>論理ゲートパズル</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body { font-family: 'Inter', sans-serif; overscroll-behavior: none; user-select: none; }
        #circuitCanvas { background-color: #334155; }
        .gate-toolbox { background-color: #475569; }
        .gate-body { cursor: grab; }
        .gate.dragging .gate-body { cursor: grabbing; }
        .gate.dragging { opacity: 0.7; }
        .pin { cursor: crosshair; }
        .wire { cursor: pointer; stroke-width: 5px; }
        .wire.on { stroke: #4ade80; }
        .wire.off { stroke: #9ca3af; }
        .led.on { fill: #facc15; }
        .led.off { fill: #6b7280; }
        #wiring-preview { stroke: #38bdf8; stroke-dasharray: 5,5; pointer-events: none; stroke-width: 3px; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; }
        .modal-content { background-color: #1f2937; color: #f1f5f9; margin: auto; padding: 20px; border: 1px solid #334155; width: 80%; max-width: 400px; border-radius: 8px; text-align: center; }
        .modal-content.large { max-width: 600px; }
        .modal-button { background-color: #0ea5e9; color: white; padding: 10px 20px; margin-top: 15px; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.15s; }
        .modal-button:hover { background-color: #0284c7; }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 flex flex-col items-center justify-center min-h-screen p-2 md:p-4">

    <div class="w-full max-w-6xl bg-slate-800 shadow-2xl rounded-xl p-4 md:p-6">
        <header class="mb-4 text-center md:flex md:justify-between md:items-center">
            <div>
                <h1 class="text-2xl md:text-3xl font-bold text-sky-400">論理ゲートパズル</h1>
                <p id="stage-title" class="text-lg md:text-xl mt-1 text-slate-300">モードを選択してください</p>
            </div>
            <div id="game-info" class="text-xl md:text-2xl font-semibold text-amber-400 flex flex-col items-center" style="position: relative; min-width: 180px;">
                <div id="score-display" style="line-height: 1; text-align: center; width: 100%;">スコア: <span id="score">0</span></div>
                <div style="display: flex; flex-direction: column; align-items: center; width: 100%;">
                    <div id="infinite-timer-display" style="display: none; margin-top: 0.2em; margin-bottom: 0.2em; text-align: center; width: 100%;" class="text-base md:text-lg text-emerald-400">
                        <span style="vertical-align: middle;">経過時間: <span id="infinite-timer">00:00</span></span>
                    </div>
                    <div id="time-attack-display" style="display: none; margin-top: 0.2em; margin-bottom: 0.2em; text-align: center; width: 100%;" class="text-base md:text-lg text-emerald-400">
                        <span style="vertical-align: middle;">残り時間: <span id="timer">0:00</span></span>
                        <span id="question-counter-wrapper" class="ml-4">問題: <span id="question-counter">0/10</span></span>
                    </div>
                </div>
            </div>
            <div class="flex gap-2 items-center justify-center mt-2 md:mt-0">
                <button id="modeSelectButton" class="bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition-colors duration-150">
                    モード選択
                </button>
                <button id="infoButton" class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition-colors duration-150">
                    ヘルプ
                </button>
            </div>
        </header>

        <div class="flex flex-col md:flex-row gap-4">
            <div class="md:w-1/4 flex flex-col gap-4">
                <div class="bg-slate-700 p-4 rounded-lg shadow">
                    <h3 class="text-lg font-semibold mb-2 text-sky-300">問題</h3>
                    <div id="problem-description"></div>
                </div>
                <div id="gate-toolbox" class="gate-toolbox p-4 rounded-lg shadow flex-grow">
                    <h3 class="text-lg font-semibold mb-3 text-sky-300">ゲートボックス</h3>
                    <div id="gate-toolbox-items" class="grid grid-cols-2 gap-2"></div>
                </div>
            </div>
            <div class="md:w-3/4 flex flex-col h-full">
                <div class="bg-slate-700 p-1 rounded-lg shadow aspect-video flex-1 w-full">
                    <svg id="circuitCanvas" width="100%" height="100%"></svg>
                </div>
                <div style="height: 28px;"></div>
                <div class="flex flex-row gap-4 mt-2" style="margin-left: 150px;">
                    <button id="resetButton" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition-colors duration-150 text-lg">
                        リセット
                    </button>
                    <button id="checkButton" class="bg-sky-500 hover:bg-sky-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition-colors duration-150 text-lg">
                        回路チェック！
                    </button>
                    <button id="infiniteEndButton"
                            style="display:none; margin-left: 32px;"
                            class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-full shadow-lg text-lg">
                        終了
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="messageModal" class="modal"><div class="modal-content"><p id="modalMessageText"></p><button id="modalCloseButton" class="modal-button">OK</button></div></div>
    <div id="explanationModal" class="modal"><div class="modal-content large"><h3 id="explanationTitle" class="text-xl font-bold mb-3 text-sky-300">正解！</h3><div id="explanationContent" class="text-left text-slate-200 text-sm"></div><button id="explanationCloseButton" class="modal-button">次へ</button></div></div>
    <div id="modeSelectModal" class="modal" style="display: flex;">
  <div class="modal-content large">
    <h3 class="text-xl font-bold mb-3 text-sky-300">モードを選択してください</h3>
    <div class="flex flex-col gap-3">
      <button class="modal-button" data-mode="infinite">無限モード</button>
      <button class="modal-button" data-mode="timeAttack">タイムアタックモード (5分 / 10問)</button>
      <button class="modal-button" data-mode="tutorial">チュートリアル</button>
      <button id="viewHighScoreButton" class="modal-button bg-amber-500 hover:bg-amber-600">スコア表示</button>
    </div>
    <div class="flex justify-center mt-6">
      <button id="modeSelectCloseButton" class="modal-button" style="background-color: #64748b; min-width: 120px;">閉じる</button>
    </div>
  </div>
</div>
    <div id="difficultyModal" class="modal">
      <div class="modal-content large">
        <h3 class="text-xl font-bold mb-3 text-sky-300">難易度を選択してください</h3>
        <div class="flex flex-col gap-3">
          <button class="modal-button" data-diff="easy">初級</button>
          <button class="modal-button" data-diff="normal">中級</button>
          <button class="modal-button" data-diff="hard">上級</button>
        </div>
      </div>
    </div>
    <div id="resultModal" class="modal">
      <div class="modal-content large">
        <h3 id="resultTitle" class="text-2xl font-bold mb-3 text-amber-400">ゲームクリア！</h3>
        <div id="resultBody" class="text-lg text-slate-200"></div>
        <button id="resultCloseButton" class="modal-button">モード選択</button>
      </div>
    </div>
    <div id="gateInfoModal" class="modal">
      <div class="modal-content large flex flex-col items-center" style="min-height: 340px; position: relative;">
        <div class="flex-1 flex flex-col items-center w-full">
          <h3 id="gateInfoTitle" class="text-xl font-bold mb-3 text-sky-300"></h3>
          <div id="gateInfoBody" class="text-left text-slate-200 text-base"></div>
        </div>
        <div class="flex flex-row items-center justify-center gap-2 mt-2">
          <button id="gateInfoPrevButton" class="modal-button" style="width: 32px; height: 48px; min-width: 0; background: rgba(30,41,59,0.7); color: #38bdf8; font-size: 1.5rem; border-radius: 8px; display: flex; align-items: center; justify-content: center; border: 1px solid #334155; z-index: 2; padding: 0;">&lt;</button>
          <button id="gateInfoCloseButton" class="modal-button" style="height: 40px; min-width: 80px;">閉じる</button>
          <button id="gateInfoNextTabButton" class="modal-button" style="width: 32px; height: 48px; min-width: 0; background: rgba(30,41,59,0.7); color: #38bdf8; font-size: 1.5rem; border-radius: 8px; display: flex; align-items: center; justify-content: center; border: 1px solid #334155; z-index: 2; padding: 0;">&gt;</button>
        </div>
      </div>
    </div>
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4 text-sky-300">ヘルプ</h3>
            <div class="flex flex-col gap-3">
                <button id="infoModalGateButton" class="modal-button">ゲート説明</button>
                <button id="infoModalOperationButton" class="modal-button">操作説明</button>
            </div>
            <button id="infoModalCloseButton" class="modal-button" style="background-color: #64748b;">閉じる</button>
        </div>
    </div>
    <div id="highScoreModal" class="modal">
    <div class="modal-content large">
        <h3 class="text-xl font-bold mb-3 text-amber-400">ハイスコア</h3>
        <div id="highScoreContent" class="text-left text-slate-200 text-base"></div>
        <button id="highScoreCloseButton" class="modal-button">閉じる</button>
    </div>
</div>
    <div id="operationInfoModal" class="modal">
        <div class="modal-content large">
            <h3 class="text-xl font-bold mb-3 text-sky-300">操作説明</h3>
            <div class="text-left text-slate-200 text-sm">
                <ul class="list-disc pl-5 space-y-2">
                    <li><b>ゲートの配置:</b> ツールボックスのゲートをクリックして、回路エリアに配置します。</li>
                    <li><b>配線:</b> ゲートや入力の丸い部分（ピン）をクリックし、接続したい先のピンをクリックすると配線できます。</li>
                    <li><b>配線の削除:</b> 作成したワイヤー（線）をクリックすると削除できます。</li>
                    <li><b>ゲートの移動:</b> 回路エリアに配置したゲートは、ドラッグして好きな場所に移動できます。</li>
                    <li><b>リセット:</b> 「リセット」ボタンを押すと、配置したゲートや配線が全て初期状態に戻ります。</li>
                    <li><b>回路チェック:</b> 回路が完成したら「回路チェック！」ボタンを押して、正解かどうかを確認します。</li>
                </ul>
            </div>
            <button id="operationInfoCloseButton" class="modal-button">閉じる</button>
        </div>
    </div>

    <script>
    // --- グローバル変数と定数 ---
    const SVG_NS = "http://www.w3.org/2000/svg";
    let score = 0;
    let stageLevel = 1;

    let currentStageData = {};
    let userCircuit = { gates: [], wires: [] };
    let savedRandomStageData = null;

    let isDragging = false, draggedElement = null, offset = { x: 0, y: 0 }, svgPoint;
    let isWiring = false, wiringStartPin = null, wiringPreviewLine = null;
    
    let scoreEl, stageTitleEl, problemDescEl, gateToolboxEl, circuitCanvasEl;
    let checkButtonEl, resetButtonEl;
    let modal, modalMessageText, modalCloseButton;
    let explanationModal, explanationContent, explanationCloseButton, explanationTitle;

    let gameMode = null;
    let difficulty = "easy";
    // ▼▼▼ 変更点 ▼▼▼ チュートリアルの総ステージ数を7に変更
    let tutorialStageCount = 7;

    // タイムアタックモード / 無限モード共通タイマー関連
    const TIME_ATTACK_TIME_LIMIT = 300; // 5分
    const INFINITE_MODE_TIME_LIMIT = 60; // 1問60秒 <--- [変更点] 無限モード用の制限時間を追加
    const TOTAL_QUESTIONS = 10;
    let timeLeft = 0;
    let timerId = null;
    let currentQuestionNumber = 1;
    let timeAttackDisplay, timerEl, questionCounterWrapper;
    let infiniteTimerEl; // グローバルで宣言

    // --- 無限モード用ストップウォッチタイマー・スコア ---
    let infiniteTimerInterval = null;
    let infiniteStartTime = null;
    let problemStartTime = null;
    let lastProblemTime = 0;
    let lastProblemScore = 0;

    // タイマー表示の初期化
    function startInfiniteTimer() {
        stopInfiniteTimer();
        infiniteStartTime = Date.now();
        document.getElementById('infinite-timer-display').style.display = 'block';
        infiniteTimerInterval = setInterval(updateInfiniteTimerDisplay, 1000);
        updateInfiniteTimerDisplay();
    }

    function stopInfiniteTimer() {
        clearInterval(infiniteTimerInterval);
        infiniteTimerInterval = null;
        document.getElementById('infinite-timer-display').style.display = 'none';
    }

    function updateInfiniteTimerDisplay() {
        if (!infiniteStartTime || !infiniteTimerEl) return;
        const elapsed = Math.floor((Date.now() - infiniteStartTime) / 1000);
        const min = Math.floor(elapsed / 60);
        const sec = elapsed % 60;
        infiniteTimerEl.textContent = `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
    }

    // --- 初期化処理 ---
    document.addEventListener('DOMContentLoaded', () => {
        const operationInfoModal = document.getElementById('operationInfoModal');
        scoreEl = document.getElementById('score');
        stageTitleEl = document.getElementById('stage-title');
        problemDescEl = document.getElementById('problem-description');
        gateToolboxEl = document.getElementById('gate-toolbox-items');
        circuitCanvasEl = document.getElementById('circuitCanvas');
        checkButtonEl = document.getElementById('checkButton');
        resetButtonEl = document.getElementById('resetButton');
        modal = document.getElementById('messageModal');
        modalMessageText = document.getElementById('modalMessageText');
        modalCloseButton = document.getElementById('modalCloseButton');
        explanationModal = document.getElementById('explanationModal');
        explanationTitle = document.getElementById('explanationTitle'); // <--- [追加] 解説モーダルのタイトル取得
        explanationContent = document.getElementById('explanationContent');
        explanationCloseButton = document.getElementById('explanationCloseButton');
        timeAttackDisplay = document.getElementById('time-attack-display');
        timerEl = document.getElementById('timer');
        questionCounterWrapper = document.getElementById('question-counter-wrapper');
        infiniteTimerEl = document.getElementById('infinite-timer');
        if (!infiniteTimerEl) {
            alert('infinite-timer要素が見つかりません。HTMLに <span id="infinite-timer">00:00</span> を追加してください。');
        }

        svgPoint = circuitCanvasEl.createSVGPoint();

        setupGateInfoModal();

        // --- チュートリアル開始時のモーダル選択 ---
        const modeSelectModal = document.getElementById('modeSelectModal');
        const modeSelectCloseButton = document.getElementById('modeSelectCloseButton');
        const difficultyModal = document.getElementById('difficultyModal');
        let tutorialStartPending = false;

        // アプリ起動時は閉じるボタンを非表示
        modeSelectCloseButton.style.display = 'none';

        // モード選択ボタンを押したときだけ閉じるボタンを表示
        document.getElementById('modeSelectButton').addEventListener('click', () => {
            modeSelectModal.style.display = 'flex';
            modeSelectCloseButton.style.display = 'block';
        });

        // モード選択モーダルのボタンを押したときは閉じるボタンを再び非表示に
        modeSelectModal.querySelectorAll('.modal-button[data-mode]').forEach(btn => {
            btn.addEventListener('click', e => {
                modeSelectCloseButton.style.display = 'none';
                gameMode = btn.getAttribute('data-mode');
                modeSelectModal.style.display = 'none';
                if (gameMode === 'tutorial') {
                    difficulty = 'tutorial';
                    tutorialStartPending = true;
                    operationInfoModal.style.display = 'flex'; // まず操作説明を表示
                } else {
                    document.getElementById('difficultyModal').style.display = 'flex';
                }
            });
        });

        // 閉じるボタンでモード選択・難易度選択ウィンドウを両方閉じる
        modeSelectCloseButton.addEventListener('click', () => {
            modeSelectModal.style.display = 'none';
            if (difficultyModal) difficultyModal.style.display = 'none';
        });

        // 操作説明モーダルの閉じるボタンでゲート説明を表示
        document.getElementById('operationInfoCloseButton').addEventListener('click', () => {
            operationInfoModal.style.display = 'none';
            if (tutorialStartPending) {
                tutorialStartPending = false;
                showGateInfoSequence();
            }
        });
        
        difficultyModal.querySelectorAll('.modal-button').forEach(btn => {
            btn.addEventListener('click', e => {
                difficulty = btn.getAttribute('data-diff');
                difficultyModal.style.display = 'none';
                startGame();
            });
        });
        
        document.getElementById('resultCloseButton').addEventListener('click', () => {
             document.getElementById('resultModal').style.display = 'none';
             modeSelectModal.style.display = 'flex';
        });

        checkButtonEl.addEventListener('click', checkSolution);
        resetButtonEl.addEventListener('click', () => loadCurrentStage());
        modalCloseButton.addEventListener('click', closeModal);
        explanationCloseButton.addEventListener('click', closeExplanationModal);
        
        // --- ヘルプモーダルのイベントリスナー ---
        const infoButton = document.getElementById('infoButton');
        const infoModal = document.getElementById('infoModal');
        const infoModalCloseButton = document.getElementById('infoModalCloseButton');
        const infoModalGateButton = document.getElementById('infoModalGateButton');
        const infoModalOperationButton = document.getElementById('infoModalOperationButton');
        
        const operationInfoCloseButton = document.getElementById('operationInfoCloseButton');

        // ヘルプボタン
        infoButton.addEventListener('click', () => {
            infoModal.style.display = 'flex';
        });

        // ヘルプモーダルの閉じる
        infoModalCloseButton.addEventListener('click', () => {
            infoModal.style.display = 'none';
        });

        // ヘルプ→ゲート説明
        infoModalGateButton.addEventListener('click', () => {
            infoModal.style.display = 'none';
            showGateInfoSequence(true);
        });

        // ヘルプ→操作説明
        infoModalOperationButton.addEventListener('click', () => {
            infoModal.style.display = 'none';
            operationInfoModal.style.display = 'flex';
        });

        // 操作説明モーダルの閉じる
        operationInfoCloseButton.addEventListener('click', () => {
            operationInfoModal.style.display = 'none';
        });

        document.addEventListener('mousedown', onMouseDown);
    });

    // --- ゲーム開始時 ---
    function startGame() {
        score = 0;
        savedRandomStageData = null;
        updateUIForNewGame();

        if (gameMode === 'infinite') {
            stageLevel = 1;
            startInfiniteTimer();
            loadStage(stageLevel);
        } else if (gameMode === 'timeAttack') {
            currentQuestionNumber = 1;
            timeLeft = TIME_ATTACK_TIME_LIMIT;
            startTimer();
            loadStage(currentQuestionNumber);
        } else {
            stopInfiniteTimer();
        }
    }
    
    // --- UI初期化 ---
    function updateUIForNewGame() {
        scoreEl.textContent = score;
        if (gameMode === 'timeAttack') {
            if (timeAttackDisplay) timeAttackDisplay.style.display = 'block';
            if (questionCounterWrapper) questionCounterWrapper.style.display = 'inline';
            updateTimerDisplay();
            document.getElementById('question-counter').textContent = `${currentQuestionNumber}/${TOTAL_QUESTIONS}`;
        } else if (gameMode === 'infinite') {
            if (timeAttackDisplay) timeAttackDisplay.style.display = 'none';
            document.getElementById('infinite-timer-display').style.display = 'block';
        } else {
            if (timeAttackDisplay) timeAttackDisplay.style.display = 'none';
            document.getElementById('infinite-timer-display').style.display = 'none';
        }
    }

    // --- タイマー管理 ---
    function startTimer() {
        if (timerId) clearInterval(timerId);
        updateTimerDisplay(); // 開始時に一度表示を更新
        timerId = setInterval(() => {
            timeLeft--;
            updateTimerDisplay();
            if (timeLeft <= 0) {
                // [変更点] 時間切れの処理をゲームモードで分岐
                if (gameMode === 'timeAttack') {
                    gameOver("時間切れ！");
                } else if (gameMode === 'infinite') {
                    timeLeft = 0; // 負の値にならないように
                    stopTimer();
                    timerEl.textContent = "時間切れ"; // 表示を更新
                }
            }
        }, 1000);
    }
    
    function stopTimer() {
        clearInterval(timerId);
        timerId = null;
    }

    function updateTimerDisplay() {
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // --- ゲーム終了処理 ---
    function gameOver(message) {
        stopTimer();
        let isHighScore = false;
        let rank = null;
        if (gameMode === "infinite") {
            isHighScore = addHighScore("infinite", score);
            rank = getHighScoreRank("infinite", score);
        } else if (gameMode === "timeAttack") {
            isHighScore = addHighScore("timeAttack", score);
            rank = getHighScoreRank("timeAttack", score);
        }
        document.getElementById('resultTitle').textContent = message;
        let resultHtml = `<p>最終スコア: <span class="font-bold text-xl">${score}</span></p>`;
        if (gameMode !== "tutorial") {
            if (isHighScore && rank !== null && rank <= 10) {
                resultHtml += `<p class="mt-2 text-emerald-400 font-bold">おめでとうございます！<br>ハイスコア${rank}位にランクインしました！</p>`;
            } else {
                // 現在のハイスコアと比較
                const scores = getHighScores();
                const modeScores = scores[gameMode] || [];
                const best = modeScores.length > 0 ? modeScores[0].score : 0;
                resultHtml += `<p class="mt-2 text-sky-300">現在のハイスコア: <b>${best}</b> ／ 今回のスコア: <b>${score}</b></p>`;
            }
        }
        document.getElementById('resultBody').innerHTML = resultHtml;
        document.getElementById('resultModal').style.display = 'flex';
    }

    function gameClear() {
        stopTimer();
        const bonusScore = timeLeft * 10;
        const finalScore = score + bonusScore;
        let isHighScore = addHighScore("timeAttack", finalScore);
        let rank = getHighScoreRank("timeAttack", finalScore);

        document.getElementById('resultTitle').textContent = "ゲームクリア！";
        let resultHtml = `
            <p>クリアタイム: <span class="font-bold">${formatTime(TIME_ATTACK_TIME_LIMIT - timeLeft)}</span></p>
            <p>基本スコア: <span class="font-bold">${score}</span></p>
            <p>タイムボーナス: <span class="font-bold">${bonusScore}</span></p>
            <hr class="my-2 border-slate-600">
            <p>最終スコア: <span class="font-bold text-2xl text-amber-300">${finalScore}</span></p>
        `;
        if (isHighScore && rank !== null && rank <= 10) {
            resultHtml += `<p class="mt-2 text-emerald-400 font-bold">おめでとうございます！<br>ハイスコア${rank}位にランクインしました！</p>`;
        } else {
            // 現在のハイスコアと比較
            const scores = getHighScores();
            const modeScores = scores["timeAttack"] || [];
            const best = modeScores.length > 0 ? modeScores[0].score : 0;
            resultHtml += `<p class="mt-2 text-sky-300">現在のハイスコア: <b>${best}</b> ／ 今回のスコア: <b>${finalScore}</b></p>`;
        }
        document.getElementById('resultBody').innerHTML = resultHtml;
        document.getElementById('resultModal').style.display = 'flex';
    }

    function formatTime(seconds) {
        const min = Math.floor(seconds / 60);
        const sec = seconds % 60;
        return `${min}分${sec}秒`;
    }
    
    // --- ステージ管理 ---
    function loadCurrentStage() {
        if(gameMode === 'tutorial') loadStage(stageLevel);
        else if (gameMode === 'infinite') loadStage(stageLevel);
        else if (gameMode === 'timeAttack') loadStage(currentQuestionNumber);
    }

    function loadStage(level) {
        userCircuit = { gates: [], wires: [] };
        circuitCanvasEl.innerHTML = '';
        if (isWiring) cancelWiring();

        // 無限モード以外はタイマー非表示
        if (gameMode !== 'infinite') stopInfiniteTimer();

        if (difficulty === "tutorial") {
            currentStageData = getTutorialStage(level);
            savedRandomStageData = null;
        } else {
             if (!savedRandomStageData) {
                 savedRandomStageData = generateRandomStage(level, difficulty);
             }
             currentStageData = savedRandomStageData;
        }

        if (gameMode === 'infinite') {
            stageTitleEl.textContent = `ステージ ${level}`;
            problemStartTime = Date.now(); // 問題ごとのストップウォッチ開始
        } else if (gameMode === 'tutorial') {
             stageTitleEl.textContent = `チュートリアル ${level}`;
        }

        scoreEl.textContent = score;
        drawProblemDescription();
        drawToolbox();
        drawCanvasNodes();
    }
    
    // --- 解答チェック ---
    function checkSolution() {
        const usedGateCount = userCircuit.gates.length;
        const availableGateCount = currentStageData.availableGates.length;
        if (usedGateCount !== availableGateCount) {
            showModal(`ツールボックスのゲートを全て使ってください。現在 ${usedGateCount} / ${availableGateCount} 個使用しています。`);
            return;
        }

        let allPatternsPass = true;
        for (const testCase of currentStageData.expectedResults) {
            const resultSignals = simulateCircuit(userCircuit, testCase.inputs);
            for (const output of currentStageData.outputs) {
                if (resultSignals[output.id] !== testCase.outputs[output.id]) {
                    allPatternsPass = false; break;
                }
            }
            if (!allPatternsPass) break;
        }

        if (allPatternsPass) {
            savedRandomStageData = null;

            if (gameMode === 'infinite') {
                // 問題ごとの経過時間（秒）
                lastProblemTime = Math.floor((Date.now() - problemStartTime) / 1000);
                // スコア計算: 100点から1秒ごとに0.5点減点、最低10点、小数点以下切り捨て
                let baseScore = 100;
                let penalty = lastProblemTime * 0.5;
                lastProblemScore = Math.max(10, Math.floor(baseScore - penalty));
                score += lastProblemScore;
                showExplanationModal(stageLevel, `ステージ ${stageLevel} クリア！`, lastProblemTime, lastProblemScore);
                stageLevel++;
            } else if (gameMode === 'timeAttack') {
                // タイムアタックモードの処理を追加
                score += 100 + (currentQuestionNumber * 10);
                showExplanationModal(currentQuestionNumber, `問題 ${currentQuestionNumber} クリア！`);
                currentQuestionNumber++;
                if (currentQuestionNumber > TOTAL_QUESTIONS) {
                    gameClear();
                } else {
                    loadStage(currentQuestionNumber);
                }
            } else if (gameMode === 'tutorial') {
                score += 10;
                showExplanationModal(stageLevel, `チュートリアル ${stageLevel} クリア！`);
                stageLevel++;
                if (stageLevel > tutorialStageCount) {
                   setTimeout(() => {
                        gameOver("チュートリアルクリア！");
                   }, 500);
                }
             }
        } else {
            showModal('不正解です。回路の接続を見直してください。');
        }
    }
    
    // --- 解説モーダル ---
    // 無限モード時はかかった時間・獲得スコアのみ表示
    function showExplanationModal(clearedStageLevel, title, problemTimeSec, problemScore) {
        let explanationHtml = '';
        if (gameMode === 'infinite' && problemTimeSec !== undefined && problemScore !== undefined) {
            explanationHtml += `
                <div class="mb-2 text-emerald-400">
                    この問題にかかった時間: <b>${Math.floor(problemTimeSec / 60)}分${problemTimeSec % 60}秒</b>
                </div>
                <div class="mb-2 text-amber-300">
                    獲得スコア: <b>${problemScore}</b>
                </div>
            `;
        }
        explanationHtml += `<p class="mb-3">${title} お見事です！</p>`;

        // --- ここからは既存の解説内容 ---
        if (clearedStageLevel === 1) {
            explanationHtml += `
                <p>このステージでは <b>NOTゲート</b> を使いました。</p>
                <p>NOTゲートは、入力と出力が逆になります。</p>
                <p>ON (真) が入力されれば OFF (偽) に、OFF (偽) が入力されれば ON (真) になります。</p>
                <table class="w-full text-center mt-3 border border-slate-600">
                    <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力 A</th><th class="p-1 border border-slate-600">出力 X</th></tr></thead>
                    <tbody>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr>
                    </tbody>
                </table>
            `;
        } else if (clearedStageLevel === 2) {
            explanationHtml += `
                <p>このステージでは <b>ANDゲート</b> を使いました。</p>
                <p>ANDゲートは、全ての入力がONの時に限り出力がONになります。</p>
                <table class="w-full text-center mt-3 border border-slate-600">
                    <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力 A</th><th class="p-1 border border-slate-600">入力 B</th><th class="p-1 border border-slate-600">出力 Y</th></tr></thead>
                    <tbody>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                    </tbody>
                </table>
            `;
        } else if (clearedStageLevel === 3) {
            explanationHtml += `
                <p>このステージでは <b>ORゲート</b> を使いました。</p>
                <p>ORゲートは、いずれかの入力がONの時に出力がONになります。</p>
                <table class="w-full text-center mt-3 border border-slate-600">
                    <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力 A</th><th class="p-1 border border-slate-600">入力 B</th><th class="p-1 border border-slate-600">出力 Z</th></tr></thead>
                    <tbody>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                    </tbody>
                </table>
            `;
        } else if (clearedStageLevel === 4) {
            explanationHtml += `
                <p>このステージでは <b>XORゲート</b> を使いました。</p>
                <p>XORゲートは、入力のいずれか一方がONの時に出力がONになります。</p>
                <table class="w-full text-center mt-3 border border-slate-600">
                    <thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力 A</th><th class="p-1 border border-slate-600">入力 B</th><th class="p-1 border border-slate-600">出力 Z</th></tr></thead>
                    <tbody>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr>
                        <tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr>
                    </tbody>
                </table>
            `;
        } else {
            // ランダム問題など
            explanationHtml += `
                <p>今回の問題は、<b>論理ゲートの組み合わせ</b> でした。</p>
                <p>正解となる回路の各ステップでの信号変化を見てみましょう。</p>
                <table class="w-full text-center mt-3 border border-slate-600">
                    <thead>
                        <tr class="bg-slate-700">
                            ${currentStageData.inputs.map(i => `<th class="p-1 border border-slate-600">${i.id}</th>`).join('')}
                            ${currentStageData.solutionCircuit && currentStageData.solutionCircuit.gates
                                ? currentStageData.solutionCircuit.gates.map(g => `<th class="p-1 border border-slate-600">${g.type}<br/>(${g.id}.output)</th>`).join('')
                                : ''
                            }
                            ${currentStageData.outputs.map(o => `<th class="p-1 border border-slate-600">${o.id}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
    `;

            currentStageData.expectedResults.forEach(res => {
                const fullSignals = simulateCircuit(currentStageData.solutionCircuit, res.inputs);
                explanationHtml += '<tr>';
                currentStageData.inputs.forEach(input => {
                    explanationHtml += `<td class="p-1 border border-slate-600">${fullSignals[input.id] ? 'ON' : 'OFF'}</td>`;
                });
                if (currentStageData.solutionCircuit && currentStageData.solutionCircuit.gates) {
                    currentStageData.solutionCircuit.gates.forEach(gate => {
                        const outputId = `${gate.id}.output`;
                        explanationHtml += `<td class="p-1 border border-slate-600">${fullSignals[outputId] ? 'ON' : 'OFF'}</td>`;
                    });
                }
                currentStageData.outputs.forEach(output => {
                    explanationHtml += `<td class="p-1 border border-slate-600 font-bold text-amber-300">${fullSignals[output.id] ? 'ON' : 'OFF'}</td>`;
                });
                explanationHtml += '</tr>';
            });

            explanationHtml += `
                    </tbody>
                </table>
                <p class="mt-3 text-sm text-slate-400">
                    ※上記の表は正解回路における各ゲートの出力状態を示しています。<br/>
                    この組み合わせで、与えられた入力を元に最終出力が生成されます。
                </p>
            `;
        }

        explanationContent.innerHTML = explanationHtml;
        explanationModal.style.display = 'flex';
    }

    function closeModal() { modal.style.display = 'none'; }
    function showModal(message) { modalMessageText.textContent = message; modal.style.display = 'flex'; }

    function closeExplanationModal() {
        explanationModal.style.display = 'none';
        if (gameMode !== 'tutorial' || stageLevel <= tutorialStageCount) {
            loadCurrentStage();
        }
    }
    
    // --- 以下、元のJavaScriptコード (変更なしの部分) ---
    // (差し替えずにそのまま利用してください)
    function getFixedStage(level) {
        if (level === 1) {
            return {
                availableGates: [{ type: 'NOT', id: 'fixed_not1' }],
                inputs: [{ id: 'A' }], outputs: [{ id: 'X' }],
                expectedResults: [{ inputs: { A: false }, outputs: { X: true } }, { inputs: { A: true }, outputs: { X: false } }]
            };
        }
        if (level === 2) {
            return {
                availableGates: [{ type: 'AND', id: 'fixed_and1' }],
                inputs: [{ id: 'A' }, { id: 'B' }], outputs: [{ id: 'Y' }],
                expectedResults: [
                    { inputs: { A: false, B: false }, outputs: { Y: false } }, { inputs: { A: true, B: false }, outputs: { Y: false } },
                    { inputs: { A: false, B: true }, outputs: { Y: false } }, { inputs: { A: true, B: true }, outputs: { Y: true } }
                ]
            };
        }
        return {};
    }
    
    function generateRandomStage(level, diff) {
        const gateTypes = ['AND', 'OR', 'NOT', 'XOR', 'NAND', 'NOR'];
        let numGates;
        if (diff === "normal") {
            numGates = Math.max(2, Math.min(Math.floor(level / 2) + 1, 4));
        } else if (diff === "hard") {
            numGates = Math.max(3, Math.min(Math.floor(level / 2) + 2, 4));
        } else {
            numGates = Math.min(Math.floor(level / 2) + 1, 3);
        }
        let availableGates = [], internalWires = [], gatePool = {};

        for (let i = 0; i < numGates; i++) {
            const type = gateTypes[Math.floor(Math.random() * gateTypes.length)];
            const id = `rand_gate${i}`;
            availableGates.push({ type, id });
            gatePool[id] = { type, inputs: [] };
        }

        const inputs = [{id: 'A'}, {id: 'B'}];
        let availableOutputs = ['A', 'B'];
        let unconnectedGates = [...availableGates];

        while(unconnectedGates.length > 0) {
            const gate = unconnectedGates.shift();
            const numInputs = gate.type === 'NOT' ? 1 : 2;
            for(let i = 0; i < numInputs; i++) {
                const sourceIndex = Math.floor(Math.random() * availableOutputs.length);
                const source = availableOutputs.length > 0 ? availableOutputs.splice(sourceIndex, 1)[0] : (Math.random() > 0.5 ? 'A' : 'B');
                internalWires.push({ from: source, to: `${gate.id}.input${i}`});
                gatePool[gate.id].inputs.push(source);
            }
            availableOutputs.push(`${gate.id}.output`);
        }
        
        const finalOutputId = availableOutputs[availableOutputs.length - 1];
        const outputs = [{id: 'Z'}];
        internalWires.push({ from: finalOutputId, to: 'Z'});

        const expectedResults = [];
        [[false, false], [false, true], [true, false], [true, true]].forEach(pattern => {
            const signal = { A: pattern[0], B: pattern[1] };
            
            let currentSignals = { ...signal };
            let updatedThisLoop = true;
            let safetyCounter = 0;
            const MAX_ITERATIONS = 20;

            while (updatedThisLoop && safetyCounter < MAX_ITERATIONS) {
                updatedThisLoop = false;
                internalWires.forEach(wire => {
                    if (currentSignals[wire.from] !== undefined && currentSignals[wire.to] === undefined) {
                        const targetGateId = wire.to.split('.')[0];
                        const gate = availableGates.find(g => g.id === targetGateId);
                        if (gate) {
                            const gateInputPins = gatePool[gate.id].inputs;
                            const allInputsReady = gateInputPins.every(inputPinId => currentSignals[inputPinId] !== undefined);
                            if (allInputsReady) {
                                const gateInputs = gateInputPins.map(inputPinId => currentSignals[inputPinId]);
                                currentSignals[`${gate.id}.output`] = calculateGateOutput(gate.type, gateInputs);
                                updatedThisLoop = true;
                            }
                        } else if (wire.to === 'Z') {
                            currentSignals['Z'] = currentSignals[wire.from];
                            updatedThisLoop = true;
                        }
                    }
                });
                safetyCounter++;
            }
            expectedResults.push({ inputs: { A: pattern[0], B: pattern[1] }, outputs: { Z: currentSignals['Z'] } });
        });

        const remappedAvailableGates = availableGates.map((gate, index) => ({ type: gate.type, id: `gate${index + 1}` }));
        const solutionCircuit = {
            gates: remappedAvailableGates.map(g => ({ id: g.id, type: g.type })),
            wires: internalWires.map(wire => {
                let from = wire.from, to = wire.to;
                remappedAvailableGates.forEach((g, index) => {
                    const originalId = availableGates[index].id;
                    if (from.startsWith(originalId)) from = from.replace(originalId, g.id);
                    if (to.startsWith(originalId)) to = to.replace(originalId, g.id);
                });
                return { from, to };
            })
        };
        return { availableGates: remappedAvailableGates, inputs, outputs, expectedResults, solutionCircuit };
    }

    function drawProblemDescription() {
        let html = '<p class="text-slate-300 mb-2">下のゲートをすべて使って、指定の出力を再現しよう。</p>';
        html += '<table class="w-full text-center">';
        const headers = [...currentStageData.inputs.map(i => i.id), ...currentStageData.outputs.map(o => o.id)];
        html += `<thead><tr>${headers.map(h => `<th class="p-1 border border-slate-500">${h}</th>`).join('')}</tr></thead>`;
        html += '<tbody>';
        currentStageData.expectedResults.forEach(res => {
            html += '<tr>';
            currentStageData.inputs.forEach(input => { html += `<td class="p-1 border border-slate-500">${res.inputs[input.id] ? 'ON' : 'OFF'}</td>`; });
            currentStageData.outputs.forEach(output => { html += `<td class="p-1 border border-slate-500 font-bold text-amber-300">${res.outputs[output.id] ? 'ON' : 'OFF'}</td>`; });
            html += '</tr>';
        });
        html += '</tbody></table>';
        problemDescEl.innerHTML = html;
    }
    function drawToolbox() {
        gateToolboxEl.innerHTML = '';
        currentStageData.availableGates.forEach(gate => {
            const g = createGateElement(gate.type, gate.id, true);
            const wrapper = document.createElement('div');
            wrapper.appendChild(g);
            gateToolboxEl.appendChild(wrapper);
        });
    }
    function drawCanvasNodes() {
        const canvasRect = circuitCanvasEl.getBoundingClientRect();
        currentStageData.inputs.forEach((input, index) => {
             const y = (canvasRect.height / (currentStageData.inputs.length + 1)) * (index + 1);
             createNode(input.id, 'input', 50, y);
        });
        currentStageData.outputs.forEach((output, index) => {
             const y = (canvasRect.height / (currentStageData.outputs.length + 1)) * (index + 1);
             createNode(output.id, 'output', canvasRect.width - 50, y);
        });
    }
    function createGateElement(type, id, isToolbox) {
        const g = document.createElementNS(SVG_NS, 'g');
        g.setAttribute('class', 'gate');
        g.setAttribute('data-id', id);
        g.setAttribute('data-type', type);
        
        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.setAttribute('width', 80);
        rect.setAttribute('height', type === 'NOT' ? 40: 60);
        rect.setAttribute('rx', 5);
        rect.setAttribute('class', 'fill-slate-500 stroke-slate-400 gate-body');
        g.appendChild(rect);

        const text = document.createElementNS(SVG_NS, 'text');
        text.setAttribute('x', 40);
        text.setAttribute('y', type === 'NOT' ? 24: 34);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('class', 'fill-sky-300 font-semibold gate-body');
        text.textContent = type;
        g.appendChild(text);

        const numInputs = type === 'NOT' ? 1 : 2;
        for (let i = 0; i < numInputs; i++) {
            g.appendChild(createPinElement(`${id}.input${i}`, 0, ((type === 'NOT' ? 40: 60) / (numInputs + 1)) * (i + 1)));
        }
        g.appendChild(createPinElement(`${id}.output`, 80, (type === 'NOT' ? 40: 60) / 2));
        
        if (isToolbox) {
             const svg = document.createElementNS(SVG_NS, 'svg');
             svg.setAttribute('viewBox', '-10 -10 100 80');
             svg.appendChild(g);
             return svg;
        }
        return g;
    }
    function createPinElement(id, cx, cy) {
        const pin = document.createElementNS(SVG_NS, 'circle');
        pin.setAttribute('class', 'pin fill-slate-400 hover:fill-sky-400');
        pin.setAttribute('data-id', id);
        pin.setAttribute('cx', cx);
        pin.setAttribute('cy', cy);
        pin.setAttribute('r', 5);
        return pin;
    }
    function createNode(id, type, x, y) {
        const g = document.createElementNS(SVG_NS, 'g');
        g.setAttribute('transform', `translate(${x}, ${y})`);
        const circle = document.createElementNS(SVG_NS, 'circle');
        circle.setAttribute('r', 10);
        circle.setAttribute('class', `pin ${type === 'input' ? 'led off' : 'led off'}`);
        circle.setAttribute('data-id', id);
        g.appendChild(circle);
        const text = document.createElementNS(SVG_NS, 'text');
        text.setAttribute('x', type === 'input' ? 15 : -15);
        text.setAttribute('y', 5);
        text.setAttribute('text-anchor', type === 'input' ? 'start' : 'end');
        text.setAttribute('class', 'fill-slate-200 font-bold');
        text.textContent = id;
        g.appendChild(text);
        circuitCanvasEl.appendChild(g);
    }
    
    function getMousePosition(evt) {
        svgPoint.x = evt.clientX;
        svgPoint.y = evt.clientY;
        return svgPoint.matrixTransform(circuitCanvasEl.getScreenCTM().inverse());
    }

    function onMouseDown(e) {
        if (e.target.classList.contains('wire')) {
            const fromId = e.target.getAttribute('data-from');
            const toId = e.target.getAttribute('data-to');
            userCircuit.wires = userCircuit.wires.filter(w => !(w.from === fromId && w.to === toId));
            drawUserWires();
            return;
        }
        const targetPin = e.target.closest('.pin');
        if (targetPin) {
            e.preventDefault();
            handlePinClick(targetPin);
            return;
        }
        const targetGateBody = e.target.closest('.gate-body');
        if (targetGateBody) {
            e.preventDefault();
            handleGateMouseDown(e, targetGateBody.closest('.gate'));
            return;
        }
        
        if (isWiring) {
            cancelWiring();
        }
    }

    function handleGateMouseDown(e, gateElement) {
        if (isWiring) cancelWiring();
        isDragging = true;

        if (gateElement.closest('#gate-toolbox')) {
            const type = gateElement.getAttribute('data-type');
            const id = gateElement.getAttribute('data-id');
            gateElement.closest('svg').parentElement.remove();

            const canvasRect = circuitCanvasEl.getBoundingClientRect();
            const gateWidth = 80, gateHeight = (type === 'NOT' ? 40 : 60);
            const centerX = canvasRect.width / 2 - gateWidth / 2;
            const centerY = canvasRect.height / 2 - gateHeight / 2;

            const newGateEl = createGateElement(type, id, false);
            circuitCanvasEl.appendChild(newGateEl);
            draggedElement = newGateEl;

            userCircuit.gates.push({type, id, x: centerX, y: centerY});
            newGateEl.setAttribute('transform', `translate(${centerX}, ${centerY})`);
            offset = { x: (getMousePosition(e).x - centerX), y: (getMousePosition(e).y - centerY) };
        } else {
            draggedElement = gateElement;
            const pos = getMousePosition(e);
            const transform = draggedElement.transform.baseVal.getItem(0);
            offset.x = pos.x - transform.matrix.e;
            offset.y = pos.y - transform.matrix.f;
        }

        draggedElement.classList.add('dragging');
        document.addEventListener('mousemove', onMouseMoveForDragging);
        document.addEventListener('mouseup', onMouseUpForDragging);
    }

    function onMouseMoveForDragging(e) {
        if (!isDragging) return;
        e.preventDefault();
        const pos = getMousePosition(e);
        const canvasRect = circuitCanvasEl.getBoundingClientRect();
        const type = draggedElement.getAttribute('data-type');
        const gateWidth = 80, gateHeight = (type === 'NOT' ? 40 : 60);
        let newX = Math.max(0, Math.min(pos.x - offset.x, canvasRect.width - gateWidth));
        let newY = Math.max(0, Math.min(pos.y - offset.y, canvasRect.height - gateHeight));
        draggedElement.setAttribute('transform', `translate(${newX}, ${newY})`);
    }

    function onMouseUpForDragging(e) {
        if (!isDragging) return;
        
        draggedElement.classList.remove('dragging');
        const gateData = userCircuit.gates.find(g => g.id === draggedElement.dataset.id);
        if (gateData) {
            const transform = draggedElement.transform.baseVal.getItem(0).matrix;
            gateData.x = transform.e;
            gateData.y = transform.f;
        }
        
        isDragging = false;
        draggedElement = null;
        drawUserWires();

        document.removeEventListener('mousemove', onMouseMoveForDragging);
        document.removeEventListener('mouseup', onMouseUpForDragging);
    }

    function handlePinClick(pinElement) {
        if (!isWiring) {
            isWiring = true;
            wiringStartPin = pinElement;
            
            wiringPreviewLine = document.createElementNS(SVG_NS, 'line');
            wiringPreviewLine.setAttribute('id', 'wiring-preview');
            const startPos = getPinPosition(wiringStartPin);
            wiringPreviewLine.setAttribute('x1', startPos.x);
            wiringPreviewLine.setAttribute('y1', startPos.y);
            wiringPreviewLine.setAttribute('x2', startPos.x);
            wiringPreviewLine.setAttribute('y2', startPos.y);
            circuitCanvasEl.appendChild(wiringPreviewLine);

            document.addEventListener('mousemove', onMouseMoveForWiring);
        } else {
            const endPin = pinElement;
            const startType = getPinType(wiringStartPin.dataset.id);
            const endType = getPinType(endPin.dataset.id);
            
            if (startType !== 'unknown' && endType !== 'unknown' && startType !== endType) {
             const fromPinId = startType === 'output' ? wiringStartPin.dataset.id : endPin.dataset.id;
             const toPinId = startType === 'input' ? wiringStartPin.dataset.id : endPin.dataset.id;
            userCircuit.wires.push({ from: fromPinId, to: toPinId });
            drawUserWires();
        }
            
            cancelWiring();
        }
    }

    function onMouseMoveForWiring(e) {
        if (!isWiring) return;
        e.preventDefault();
        const pos = getMousePosition(e);
        wiringPreviewLine.setAttribute('x2', pos.x);
        wiringPreviewLine.setAttribute('y2', pos.y);
    }
    
    function cancelWiring() {
        isWiring = false;
        wiringStartPin = null;
        if (wiringPreviewLine) {
            circuitCanvasEl.removeChild(wiringPreviewLine);
            wiringPreviewLine = null;
        }
        document.removeEventListener('mousemove', onMouseMoveForWiring);
    }

    function drawUserWires() {
        circuitCanvasEl.querySelectorAll('.wire').forEach(w => w.remove());
        userCircuit.wires.forEach(wire => {
             const fromPin = circuitCanvasEl.querySelector(`[data-id="${wire.from}"]`);
             const toPin = circuitCanvasEl.querySelector(`[data-id="${wire.to}"]`);
             if(fromPin && toPin) {
                 const line = document.createElementNS(SVG_NS, 'line');
                 const p1 = getPinPosition(fromPin);
                 const p2 = getPinPosition(toPin);
                 line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y);
                 line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
                 line.setAttribute('class', 'wire off');
                 line.setAttribute('data-from', wire.from);
                 line.setAttribute('data-to', wire.to);
                 circuitCanvasEl.insertBefore(line, circuitCanvasEl.firstChild);
             }
        });
    }

    function getPinPosition(pin) {
        const parentG = pin.closest('g');
        const transform = parentG.transform.baseVal.getItem(0).matrix;
        const cx = parseFloat(pin.getAttribute('cx') || 0);
        const cy = parseFloat(pin.getAttribute('cy') || 0);
        return { x: cx + transform.e, y: cy + transform.f };
    }

    function getPinType(pinId) {
        if (pinId.includes('.output')) return 'output';
        if (pinId.includes('.input')) return 'input';
        if (currentStageData.inputs.some(i => i.id === pinId)) return 'output';
        if (currentStageData.outputs.some(o => o.id === pinId)) return 'input';
        return 'unknown';
    }
    
    function calculateGateOutput(type, inputs) {
        switch (type) {
            case 'NOT': return !inputs[0];
            case 'AND': return inputs[0] && inputs[1];
            case 'OR':  return inputs[0] || inputs[1];
            case 'XOR': return inputs[0] !== inputs[1];
            case 'NAND': return !(inputs[0] && inputs[1]);
            case 'NOR':  return !(inputs[0] || inputs[1]);
            default: return false;
        }
    }

    function simulateCircuit(circuit, inputValues) {
        const signals = { ...inputValues };
        let changed = true;
        let iterations = 0;
        const MAX_ITERATIONS = 20;

        while(changed && iterations < MAX_ITERATIONS) {
            changed = false;
            circuit.gates.forEach(gate => {
                const outputId = `${gate.id}.output`;
                if(signals[outputId] === undefined) {
                    const inputWires = circuit.wires.filter(w => w.to.startsWith(gate.id));
                    const gateInputs = [];
                    let allInputsReady = true;
                    if (gate.type === 'NOT') {
                        const inputPinId = `${gate.id}.input0`;
                        const connectedWire = inputWires.find(w => w.to === inputPinId);
                        if (connectedWire && signals[connectedWire.from] !== undefined) {
                            gateInputs.push(signals[connectedWire.from]);
                        } else {
                            allInputsReady = false;
                        }
                    } else {
                        const input0PinId = `${gate.id}.input0`;
                        const input1PinId = `${gate.id}.input1`;
                        const connectedWire0 = inputWires.find(w => w.to === input0PinId);
                        const connectedWire1 = inputWires.find(w => w.to === input1PinId);
                        
                        if (connectedWire0 && signals[connectedWire0.from] !== undefined &&
                            connectedWire1 && signals[connectedWire1.from] !== undefined) {
                            gateInputs.push(signals[connectedWire0.from]);
                            gateInputs.push(signals[connectedWire1.from]);
                        } else {
                            allInputsReady = false;
                        }
                    }

                    if(allInputsReady && gateInputs.length > 0) {
                        signals[outputId] = calculateGateOutput(gate.type, gateInputs);
                        changed = true;
                    }
                }
            });

            currentStageData.outputs.forEach(outputNode => {
                if (signals[outputNode.id] === undefined) {
                    const finalWire = circuit.wires.find(w => w.to === outputNode.id);
                    if (finalWire && signals[finalWire.from] !== undefined) {
                        signals[outputNode.id] = signals[finalWire.from];
                        changed = true;
                    }
                }
            });
            iterations++;
        }
        return signals;
    }
    
    // ▼▼▼ 変更点 ▼▼▼ チュートリアルステージの定義を修正
    function getTutorialStage(level) {
        if (level === 1) return getFixedStage(1);
        if (level === 2) return getFixedStage(2);
        if (level === 3) {
            return {
                availableGates: [{ type: 'OR', id: 'fixed_or1' }],
                inputs: [{ id: 'A' }, { id: 'B' }], outputs: [{ id: 'Z' }],
                expectedResults: [
                    { inputs: { A: false, B: false }, outputs: { Z: false } },
                    { inputs: { A: true, B: false }, outputs: { Z: true } },
                    { inputs: { A: false, B: true }, outputs: { Z: true } },
                    { inputs: { A: true, B: true }, outputs: { Z: true } }
                ],
                solutionCircuit: { gates: [{ id: 'fixed_or1', type: 'OR' }], wires: [ { from: 'A', to: 'fixed_or1.input0' }, { from: 'B', to: 'fixed_or1.input1' }, { from: 'fixed_or1.output', to: 'Z' } ] }
            };
        }
        if (level === 4) {
            return {
                availableGates: [{ type: 'XOR', id: 'fixed_xor1' }],
                inputs: [{ id: 'A' }, { id: 'B' }], outputs: [{ id: 'Z' }],
                expectedResults: [
                    { inputs: { A: false, B: false }, outputs: { Z: false } }, { inputs: { A: true, B: false }, outputs: { Z: true } },
                    { inputs: { A: false, B: true }, outputs: { Z: true } }, { inputs: { A: true, B: true }, outputs: { Z: false } }
                ],
                solutionCircuit: { gates: [{ id: 'fixed_xor1', type: 'XOR' }], wires: [ { from: 'A', to: 'fixed_xor1.input0' }, { from: 'B', to: 'fixed_xor1.input1' }, { from: 'fixed_xor1.output', to: 'Z' } ] }
            };
        }
        if (level === 5) { // 新しいNANDステージ
            return {
                availableGates: [{ type: 'NAND', id: 'fixed_nand1' }],
                inputs: [{ id: 'A' }, { id: 'B' }], outputs: [{ id: 'Z' }],
                expectedResults: [
                    { inputs: { A: false, B: false }, outputs: { Z: true } }, { inputs: { A: true, B: false }, outputs: { Z: true } },
                    { inputs: { A: false, B: true }, outputs: { Z: true } }, { inputs: { A: true, B: true }, outputs: { Z: false } }
                ],
                solutionCircuit: { gates: [{ id: 'fixed_nand1', type: 'NAND' }], wires: [ { from: 'A', to: 'fixed_nand1.input0' }, { from: 'B', to: 'fixed_nand1.input1' }, { from: 'fixed_nand1.output', to: 'Z' } ] }
            };
        }
        if (level === 6) { // 新しいNORステージ
            return {
                availableGates: [{ type: 'NOR', id: 'fixed_nor1' }],
                inputs: [{ id: 'A' }, { id: 'B' }], outputs: [{ id: 'Z' }],
                expectedResults: [
                    { inputs: { A: false, B: false }, outputs: { Z: true } }, { inputs: { A: true, B: false }, outputs: { Z: false } },
                    { inputs: { A: false, B: true }, outputs: { Z: false } }, { inputs: { A: true, B: true }, outputs: { Z: false } }
                ],
                solutionCircuit: { gates: [{ id: 'fixed_nor1', type: 'NOR' }], wires: [ { from: 'A', to: 'fixed_nor1.input0' }, { from: 'B', to: 'fixed_nor1.input1' }, { from: 'fixed_nor1.output', to: 'Z' } ] }
            };
        }
        if (level === 7) { // 組み合わせステージ（旧ステージ5）
            return {
                availableGates: [ { type: 'AND', id: 'fixed_and2' }, { type: 'NOT', id: 'fixed_not2' } ],
                inputs: [{ id: 'A' }, { id: 'B' }], outputs: [{ id: 'Z' }],
                expectedResults: [
                    { inputs: { A: false, B: false }, outputs: { Z: true } }, { inputs: { A: true, B: false }, outputs: { Z: true } },
                    { inputs: { A: false, B: true }, outputs: { Z: true } }, { inputs: { A: true, B: true }, outputs: { Z: false } }
                ],
                solutionCircuit: { gates: [ { id: 'fixed_and2', type: 'AND' }, { id: 'fixed_not2', type: 'NOT' } ], wires: [ { from: 'A', to: 'fixed_and2.input0' }, { from: 'B', to: 'fixed_and2.input1' }, { from: 'fixed_and2.output', to: 'fixed_not2.input0' }, { from: 'fixed_not2.output', to: 'Z' } ] }
            };
        }
        return { availableGates: [], inputs: [], outputs: [], expectedResults: [] };
    }

    const gateTutorials = [
        { title: "NOTゲート（否定）", body: `<p>NOTゲートは入力の値を反転します。</p><ul class="list-disc ml-5 my-2"><li>入力がON（真）のとき、出力はOFF（偽）</li><li>入力がOFF（偽）のとき、出力はON（真）</li></ul><table class="w-full text-center mt-2 border border-slate-600"><thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力</th><th class="p-1 border border-slate-600">出力</th></tr></thead><tbody><tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr></tbody></table>`},
        { title: "ANDゲート（論理積）", body: `<p>ANDゲートはすべての入力がON（真）のときだけ出力がONになります。</p><table class="w-full text-center mt-2 border border-slate-600"><thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力A</th><th class="p-1 border border-slate-600">入力B</th><th class="p-1 border border-slate-600">出力</th></tr></thead><tbody><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr><tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr>
                        <tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                    </tbody>
                </table>` },
        { title: "ORゲート（論理和）", body: `<p>ORゲートはどちらか一方でも入力がON（真）なら出力がONになります。</p><table class="w-full text-center mt-2 border border-slate-600"><thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力A</th><th class="p-1 border border-slate-600">入力B</th><th class="p-1 border border-slate-600">出力</th></tr></thead><tbody><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr><tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr><tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr>
                    </tbody>
                </table>` },
        { title: "XORゲート（排他的論理和）", body: `<p>XORゲートは入力が異なるときだけ出力がON（真）になります。</p><table class="w-full text-center mt-2 border border-slate-600"><thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力A</th><th class="p-1 border border-slate-600">入力B</th><th class="p-1 border border-slate-600">出力</th></tr></thead><tbody><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr><tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr><tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr></tbody></table>` },
        { title: "NANDゲート（否定論理積）", body: `<p>NANDゲートはANDゲートの逆です。両方の入力がONのときだけOFFになります。</p><table class="w-full text-center mt-2 border border-slate-600"><thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力A</th><th class="p-1 border border-slate-600">入力B</th><th class="p-1 border border-slate-600">出力</th></tr></thead><tbody><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr><tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td></tr><tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr></tbody></table>` },
        { title: "NORゲート（否定論理和）", body: `<p>NORゲートはORゲートの逆です。両方の入力がOFFのときだけONになります。</p><table class="w-full text-center mt-2 border border-slate-600"><thead><tr class="bg-slate-700"><th class="p-1 border border-slate-600">入力A</th><th class="p-1 border border-slate-600">入力B</th><th class="p-1 border border-slate-600">出力</th></tr></thead><tbody><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td></tr><tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">OFF</td></tr><tr><td class="p-1 border border-slate-600">OFF</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr><tr><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">ON</td><td class="p-1 border border-slate-600">OFF</td></tr></tbody></table>` }
    ];

    let gateInfoModal, gateInfoTitle, gateInfoBody, gateInfoCloseButton, gateInfoPrevButton, gateInfoNextTabButton;
    let gateInfoIndex = 0;
    let isGateInfoOnly = false;

    function showGateInfoSequence(gateInfoOnly = false) {
        gateInfoIndex = 0;
        isGateInfoOnly = gateInfoOnly;
        showGateInfoModal(gateInfoIndex);
    }

    function showGateInfoModal(index) {
        gateInfoTitle.innerHTML = gateTutorials[index].title;
        gateInfoBody.innerHTML = gateTutorials[index].body;
        gateInfoModal.style.display = 'flex';
    }

    function closeGateInfoModal() {
        gateInfoModal.style.display = 'none';
    }

    function setupGateInfoModal() {
        gateInfoModal = document.getElementById('gateInfoModal');
        gateInfoTitle = document.getElementById('gateInfoTitle');
        gateInfoBody = document.getElementById('gateInfoBody');
        gateInfoCloseButton = document.getElementById('gateInfoCloseButton');
        gateInfoPrevButton = document.getElementById('gateInfoPrevButton');
        gateInfoNextTabButton = document.getElementById('gateInfoNextTabButton');

        gateInfoCloseButton.addEventListener('click', () => {
            closeGateInfoModal();
            if (!isGateInfoOnly) {
                gameMode = 'tutorial';
                difficulty = 'tutorial';
                stageLevel = 1;
                score = 0;
                updateUIForNewGame();
                loadStage(1);
            }
        });

        gateInfoPrevButton.addEventListener('click', () => {
            gateInfoIndex = (gateInfoIndex - 1 + gateTutorials.length) % gateTutorials.length;
            showGateInfoModal(gateInfoIndex);
        });

        gateInfoNextTabButton.addEventListener('click', () => {
            gateInfoIndex = (gateInfoIndex + 1) % gateTutorials.length;
            showGateInfoModal(gateInfoIndex);
        });
    }

    // --- ハイスコア管理 ---
const HIGH_SCORE_KEY = "logicGateHighScores";
function getHighScores() {
    const data = localStorage.getItem(HIGH_SCORE_KEY);
    if (!data) return { infinite: [], timeAttack: [] };
    try {
        return JSON.parse(data);
    } catch {
        return { infinite: [], timeAttack: [] };
    }
}
function saveHighScores(scores) {
    localStorage.setItem(HIGH_SCORE_KEY, JSON.stringify(scores));
}
function addHighScore(mode, score) {
    if (mode === "tutorial") return false;
    const scores = getHighScores();
    if (!scores[mode]) scores[mode] = [];
    scores[mode].push({ score, date: new Date().toLocaleString() });
    scores[mode].sort((a, b) => b.score - a.score);
    if (scores[mode].length > 10) scores[mode] = scores[mode].slice(0, 10);
    saveHighScores(scores);
    // 追加したスコアが10位以内か判定
    return scores[mode].some(s => s.score === score && s.date === scores[mode][scores[mode].indexOf(s)].date);
}
function getHighScoreRank(mode, score) {
    if (mode === "tutorial") return null;
    const scores = getHighScores();
    if (!scores[mode]) return null;
    const idx = scores[mode].findIndex(s => s.score === score);
    return idx >= 0 ? idx + 1 : null;
}

// --- ハイスコア表示 ---
function showHighScoreModal() {
    const scores = getHighScores();
    let html = '';
    ["infinite", "timeAttack"].forEach(mode => {
        html += `<h4 class="font-bold text-lg mt-2 mb-1 text-sky-300">${mode === "infinite" ? "無限モード" : "タイムアタック"}</h4>`;
        if (scores[mode] && scores[mode].length > 0) {
            html += `<ol class="list-decimal ml-6 mb-2">`;
            scores[mode].forEach((s, i) => {
                html += `<li>${s.score}点 <span class="text-xs text-slate-400">(${s.date})</span></li>`;
            });
            html += `</ol>`;
        } else {
            html += `<p class="text-slate-400 mb-2">記録なし</p>`;
        }
    });
    document.getElementById('highScoreContent').innerHTML = html;
    document.getElementById('highScoreModal').style.display = 'flex';
}

// --- DOMContentLoaded内にイベント追加 ---
document.addEventListener('DOMContentLoaded', () => {
    // ...既存の初期化...
    const infiniteEndButton = document.getElementById('infiniteEndButton');
    const modeSelectModal = document.getElementById('modeSelectModal');
    const resultModal = document.getElementById('resultModal');

    // 無限モード時のみ終了ボタン表示
    function updateInfiniteEndButton() {
        if (gameMode === 'infinite') {
            infiniteEndButton.style.display = 'block';
        } else {
            infiniteEndButton.style.display = 'none';
        }
    }

    // ゲーム開始時にボタン表示を更新
    const origStartGame = window.startGame || startGame;
    window.startGame = function() {
        origStartGame.apply(this, arguments);
        updateInfiniteEndButton();
    };

    // 終了ボタン押下時
    infiniteEndButton.addEventListener('click', () => {
        // 無限モードのスコア処理
        gameOver("無限モード終了");
        infiniteEndButton.style.display = 'none';
    });

    // スコアウィンドウ閉じたらモード選択に戻る
    document.getElementById('resultCloseButton').addEventListener('click', () => {
        resultModal.style.display = 'none';
        modeSelectModal.style.display = 'flex';
        infiniteEndButton.style.display = 'none';
    });

    // ゲーム終了時にもボタンを消す
    const origGameOver = window.gameOver || gameOver;
    window.gameOver = function() {
        origGameOver.apply(this, arguments);
        infiniteEndButton.style.display = 'none';
    };
    
    const highScoreModal = document.getElementById('highScoreModal');
    const viewHighScoreButton = document.getElementById('viewHighScoreButton');
    const highScoreCloseButton = document.getElementById('highScoreCloseButton');

    // スコア表示ボタンでスコアウィンドウを開く
    viewHighScoreButton.addEventListener('click', () => {
        modeSelectModal.style.display = 'none';
        showHighScoreModal();
    });

    // スコアウィンドウの閉じるでモード選択に戻る
    highScoreCloseButton.addEventListener('click', () => {
        highScoreModal.style.display = 'none';
        modeSelectModal.style.display = 'flex';
    });
});
</script>
</body>
</html>